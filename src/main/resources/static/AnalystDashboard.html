<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyst Dashboard - AgriGuard AI</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        :root {
          --primary-green: #22c55e;
          --primary-dark: #16a34a;
          --secondary-green: #10b981;
          --accent-green: #34d399;
          --light-green: #dcfce7;
          --dark-green: #166534;
          --forest-green: #065f46;
          --success-color: #22c55e;
          --warning-color: #f59e0b;
          --error-color: #ef4444;
          --info-color: #3b82f6;
          --bg-primary: #ffffff;
          --bg-secondary: #f8f9fa;
          --bg-sidebar: #e8f5e8;
          --text-primary: #333333;
          --text-secondary: #666666;
          --border-color: #e0e0e0;
          --hover-bg: rgba(34, 197, 94, 0.1);
          --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
          --shadow-lg: 0 8px 25px rgba(34, 197, 94, 0.15);
          --gradient-primary: linear-gradient(135deg, var(--primary-green), var(--secondary-green));
          --gradient-bg: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 50%, #bbf7d0 100%);
          --card-bg: #ffffff;
          --modal-bg: rgba(0, 0, 0, 0.5);
        }

        .dark-mode {
          --bg-primary: #1a1a1a;
          --bg-secondary: #2d2d2d;
          --bg-sidebar: #1f2937;
          --text-primary: #ffffff;
          --text-secondary: #cccccc;
          --border-color: #404040;
          --hover-bg: rgba(34, 197, 94, 0.2);
          --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
          --card-bg: #374151;
          --gradient-bg: linear-gradient(135deg, #1f2937 0%, #374151 50%, #4b5563 100%);
        }

        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }

        body {
          font-family: 'Inter', sans-serif;
          background: var(--gradient-bg);
          color: var(--text-primary);
          transition: all 0.3s ease;
          overflow-x: hidden;
        }

        .dashboard-container {
          display: flex;
          height: 100vh;
        }

        .sidebar {
          width: 280px;
          background: var(--bg-sidebar);
          border-right: 1px solid var(--border-color);
          display: flex;
          flex-direction: column;
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          position: fixed;
          height: 100vh;
          z-index: 1000;
          box-shadow: var(--shadow);
        }

        .sidebar.collapsed {
          width: 70px;
        }

        .sidebar-header {
          padding: 20px;
          border-bottom: 1px solid var(--border-color);
          display: flex;
          align-items: center;
          gap: 12px;
        }

        .logo {
          width: 45px;
          height: 45px;
          border-radius: 12px;
          display: flex;
          align-items: center;
          justify-content: center;
          background: var(--gradient-primary);
          color: white;
          font-size: 24px;
          box-shadow: var(--shadow);
          animation: pulse 2s infinite;
        }

        @keyframes pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.05); }
        }

        .company-info {
          flex: 1;
          transition: opacity 0.3s ease;
        }

        .company-name {
          font-size: 18px;
          font-weight: 700;
          color: var(--text-primary);
          margin-bottom: 2px;
        }

        .company-tagline {
          font-size: 11px;
          color: var(--primary-green);
          font-weight: 600;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }

        .sidebar.collapsed .company-info {
          opacity: 0;
          width: 0;
        }

        .sidebar-nav {
          flex: 1;
          padding: 20px 0;
          overflow-y: auto;
        }

        .nav-section {
          margin-bottom: 30px;
        }

        .nav-section-title {
          padding: 0 20px 10px;
          font-size: 11px;
          font-weight: 700;
          color: var(--primary-green);
          text-transform: uppercase;
          letter-spacing: 1px;
          transition: opacity 0.3s ease;
        }

        .sidebar.collapsed .nav-section-title {
          opacity: 0;
          height: 0;
          margin: 0;
          padding: 0;
        }

        .nav-menu {
          list-style: none;
        }

        .nav-item {
          margin-bottom: 4px;
        }

        .nav-link {
          display: flex;
          align-items: center;
          padding: 14px 20px;
          color: var(--text-primary);
          text-decoration: none;
          border-radius: 0 25px 25px 0;
          margin-right: 20px;
          transition: all 0.3s ease;
          position: relative;
          overflow: hidden;
          cursor: pointer;
        }

        .nav-link i {
          width: 22px;
          margin-right: 14px;
          font-size: 18px;
          flex-shrink: 0;
        }

        .nav-link span {
          transition: opacity 0.3s ease;
          white-space: nowrap;
          font-weight: 500;
        }

        .sidebar.collapsed .nav-link span {
          opacity: 0;
        }

        .sidebar.collapsed .nav-link {
          margin-right: 0;
          border-radius: 0;
          justify-content: center;
        }

        .nav-link:hover {
          background: var(--hover-bg);
          color: var(--primary-green);
          transform: translateX(5px);
        }

        .nav-item.active .nav-link {
          background: var(--gradient-primary);
          color: white;
          box-shadow: var(--shadow);
        }

        .main-content {
          flex: 1;
          display: flex;
          flex-direction: column;
          margin-left: 280px;
          transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-collapsed {
          margin-left: 70px;
        }

        .header {
          background: var(--card-bg);
          border-bottom: 1px solid var(--border-color);
          padding: 0 32px;
          display: flex;
          justify-content: space-between;
          align-items: center;
          height: 80px;
          box-shadow: var(--shadow);
          backdrop-filter: blur(10px);
        }

        .header-left {
          display: flex;
          align-items: center;
          gap: 24px;
        }

        .sidebar-toggle {
          background: none;
          border: none;
          color: var(--text-primary);
          font-size: 20px;
          cursor: pointer;
          padding: 12px;
          border-radius: 12px;
          transition: all 0.3s ease;
        }

        .sidebar-toggle:hover {
          background: var(--hover-bg);
          color: var(--primary-green);
          transform: scale(1.1);
        }

        .greeting-section {
          display: flex;
          flex-direction: column;
        }

        .greeting-text {
          font-size: 24px;
          font-weight: 700;
          color: var(--text-primary);
          margin-bottom: 2px;
        }

        .current-date {
          font-size: 14px;
          color: var(--text-secondary);
          font-weight: 500;
        }

        .header-right {
          display: flex;
          align-items: center;
          gap: 20px;
        }

        .theme-toggle {
          background: var(--card-bg);
          border: 2px solid var(--border-color);
          color: var(--text-primary);
          padding: 12px 16px;
          border-radius: 12px;
          cursor: pointer;
          transition: all 0.3s ease;
          font-size: 16px;
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .theme-toggle:hover {
          background: var(--hover-bg);
          border-color: var(--primary-green);
          transform: translateY(-2px);
        }

        .profile-section {
          display: flex;
          align-items: center;
          gap: 12px;
          cursor: pointer;
          padding: 8px 16px;
          border-radius: 12px;
          transition: all 0.3s ease;
        }

        .profile-section:hover {
          background: var(--hover-bg);
        }

        .profile-avatar {
          width: 45px;
          height: 45px;
          background: var(--gradient-primary);
          color: white;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-weight: 700;
          font-size: 16px;
          transition: all 0.3s ease;
          box-shadow: var(--shadow);
        }

        .profile-info {
          display: flex;
          flex-direction: column;
        }

        .profile-name {
          font-size: 14px;
          font-weight: 600;
          color: var(--text-primary);
        }

        .profile-role {
          font-size: 12px;
          color: var(--primary-green);
          font-weight: 500;
        }

        .logout-btn {
          background: transparent;
          border: none;
          color: var(--text-secondary);
          font-size: 20px;
          cursor: pointer;
          padding: 8px;
          border-radius: 8px;
          transition: all 0.3s ease;
          margin-left: 12px;
        }

        .logout-btn:hover {
          background: rgba(239, 68, 68, 0.1);
          color: var(--error-color);
          transform: scale(1.1);
        }

        .content {
          flex: 1;
          padding: 32px;
          background: var(--bg-secondary);
          overflow-y: auto;
          min-height: calc(100vh - 80px);
        }

        .stats-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
          gap: 24px;
          margin-bottom: 32px;
          animation: fadeInUp 0.6s ease;
        }

        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        .stat-card {
          background: var(--card-bg);
          padding: 24px;
          border-radius: 16px;
          box-shadow: var(--shadow);
          transition: all 0.3s ease;
          border: 1px solid var(--border-color);
          position: relative;
          overflow: hidden;
        }

        .stat-card::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          height: 4px;
          background: var(--gradient-primary);
        }

        .stat-card:hover {
          transform: translateY(-5px);
          box-shadow: var(--shadow-lg);
        }

        .stat-icon {
          width: 50px;
          height: 50px;
          border-radius: 12px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 24px;
          color: white;
          margin-bottom: 12px;
        }

        .stat-icon.transactions { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .stat-icon.revenue { background: linear-gradient(135deg, #22c55e, #16a34a); }
        .stat-icon.farmers { background: linear-gradient(135deg, #3b82f6, #1d4ed8); }
        .stat-icon.buyers { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .stat-icon.crops { background: linear-gradient(135deg, #10b981, #047857); }
        .stat-icon.weather { background: linear-gradient(135deg, #06b6d4, #0891b2); }
        .stat-icon.soil { background: linear-gradient(135deg, #84cc16, #65a30d); }
        .stat-icon.market { background: linear-gradient(135deg, #ef4444, #dc2626); }

        .stat-value {
          font-size: 32px;
          font-weight: 700;
          color: var(--text-primary);
          margin-bottom: 4px;
        }

        .stat-label {
          font-size: 14px;
          color: var(--text-secondary);
          font-weight: 500;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }

        .stat-trend {
          display: flex;
          align-items: center;
          gap: 4px;
          margin-top: 8px;
          font-size: 13px;
          font-weight: 600;
        }

        .stat-trend.up {
          color: var(--success-color);
        }

        .stat-trend.down {
          color: var(--error-color);
        }

        .charts-section {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
          gap: 24px;
          margin-bottom: 32px;
          animation: fadeInUp 0.8s ease;
        }

        .chart-card {
          background: var(--card-bg);
          padding: 24px;
          border-radius: 16px;
          box-shadow: var(--shadow);
          border: 1px solid var(--border-color);
        }

        .chart-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 20px;
        }

        .chart-title {
          font-size: 18px;
          font-weight: 600;
          color: var(--text-primary);
        }

        .chart-container {
          position: relative;
          height: 350px;
        }

        .ai-predictions-section {
          margin-bottom: 32px;
        }

        .ai-prediction-card {
          background: var(--card-bg);
          padding: 24px;
          border-radius: 16px;
          box-shadow: var(--shadow);
          border-left: 4px solid var(--primary-green);
          margin-bottom: 16px;
          animation: fadeInUp 1s ease;
        }

        .prediction-header {
          display: flex;
          align-items: center;
          gap: 12px;
          margin-bottom: 12px;
        }

        .prediction-icon {
          width: 40px;
          height: 40px;
          border-radius: 10px;
          background: var(--gradient-primary);
          color: white;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 20px;
        }

        .prediction-title {
          font-size: 16px;
          font-weight: 600;
          color: var(--text-primary);
        }

        .prediction-content {
          color: var(--text-secondary);
          font-size: 14px;
          line-height: 1.6;
          margin-bottom: 12px;
        }

        .prediction-metrics {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
          gap: 12px;
          margin-top: 16px;
        }

        .prediction-metric {
          padding: 12px;
          background: var(--bg-secondary);
          border-radius: 8px;
        }

        .prediction-metric-label {
          font-size: 12px;
          color: var(--text-secondary);
          margin-bottom: 4px;
        }

        .prediction-metric-value {
          font-size: 18px;
          font-weight: 700;
          color: var(--primary-green);
        }

        .table-section {
          background: var(--card-bg);
          border-radius: 16px;
          box-shadow: var(--shadow);
          border: 1px solid var(--border-color);
          overflow: hidden;
          margin-bottom: 32px;
          animation: fadeInUp 1.2s ease;
        }

        .table-header {
          padding: 24px;
          border-bottom: 1px solid var(--border-color);
          display: flex;
          justify-content: space-between;
          align-items: center;
        }

        .table-title {
          font-size: 20px;
          font-weight: 600;
          color: var(--text-primary);
        }

        .table-actions {
          display: flex;
          gap: 12px;
        }

        .btn {
          padding: 10px 20px;
          border: none;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .btn-primary {
          background: var(--gradient-primary);
          color: white;
          box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }

        .btn-primary:hover {
          transform: translateY(-2px);
          box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
        }

        .btn-secondary {
          background: var(--bg-secondary);
          color: var(--text-primary);
          border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
          background: var(--hover-bg);
          border-color: var(--primary-green);
        }

        .data-table {
          width: 100%;
          border-collapse: collapse;
        }

        .data-table th,
        .data-table td {
          padding: 16px;
          text-align: left;
          border-bottom: 1px solid var(--border-color);
        }

        .data-table th {
          background: var(--bg-secondary);
          font-weight: 600;
          color: var(--text-primary);
          font-size: 13px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }

        .data-table td {
          color: var(--text-primary);
          font-size: 14px;
        }

        .data-table tr:hover {
          background: var(--hover-bg);
        }

        .loading-overlay {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.7);
          z-index: 9999;
          align-items: center;
          justify-content: center;
        }

        .loading-overlay.show {
          display: flex;
        }

        .loader {
          border: 8px solid #f3f3f3;
          border-top: 8px solid var(--primary-green);
          border-radius: 50%;
          width: 60px;
          height: 60px;
          animation: spin 1s linear infinite;
        }

        @keyframes spin {
          to { transform: rotate(360deg); }
        }

        .toast-container {
          position: fixed;
          top: 20px;
          right: 20px;
          z-index: 3000;
        }

        .toast {
          background: var(--card-bg);
          border-radius: 12px;
          padding: 16px 20px;
          margin-bottom: 12px;
          box-shadow: var(--shadow-lg);
          border-left: 4px solid;
          animation: slideInRight 0.3s ease;
          max-width: 400px;
        }

        .toast.success { border-left-color: var(--success-color); }
        .toast.error { border-left-color: var(--error-color); }
        .toast.warning { border-left-color: var(--warning-color); }
        .toast.info { border-left-color: var(--info-color); }

        @keyframes slideInRight {
          from {
            opacity: 0;
            transform: translateX(100%);
          }
          to {
            opacity: 1;
            transform: translateX(0);
          }
        }

        .content-section {
          display: none;
        }

        .content-section.active {
          display: block;
        }

        .insights-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
          gap: 24px;
          margin-bottom: 32px;
        }

        .insight-card {
          background: var(--card-bg);
          padding: 20px;
          border-radius: 12px;
          border-left: 4px solid;
          box-shadow: var(--shadow);
        }

        .insight-card.positive { border-left-color: var(--success-color); }
        .insight-card.warning { border-left-color: var(--warning-color); }
        .insight-card.critical { border-left-color: var(--error-color); }
        .insight-card.info { border-left-color: var(--info-color); }

        .insight-header {
          display: flex;
          align-items: center;
          gap: 10px;
          margin-bottom: 10px;
        }

        .insight-icon {
          font-size: 24px;
        }

        .insight-title {
          font-size: 15px;
          font-weight: 600;
          color: var(--text-primary);
        }

        .insight-description {
          font-size: 14px;
          color: var(--text-secondary);
          line-height: 1.5;
        }

        ::-webkit-scrollbar {
          width: 8px;
          height: 8px;
        }

        ::-webkit-scrollbar-track {
          background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
          background: var(--primary-green);
          border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
          background: var(--primary-dark);
        }

        /* AI Chat Styles */
        .ai-chat-container {
          display: flex;
          flex-direction: column;
          height: calc(100vh - 160px);
          background: var(--card-bg);
          border-radius: 16px;
          box-shadow: var(--shadow);
          border: 1px solid var(--border-color);
          overflow: hidden;
        }

        .chat-header {
          padding: 20px 24px;
          border-bottom: 1px solid var(--border-color);
          background: var(--gradient-primary);
          color: white;
          display: flex;
          align-items: center;
          gap: 12px;
        }

        .chat-header-icon {
          width: 40px;
          height: 40px;
          background: rgba(255, 255, 255, 0.2);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 20px;
        }

        .chat-header-title {
          font-size: 18px;
          font-weight: 600;
        }

        .chat-messages {
          flex: 1;
          overflow-y: auto;
          padding: 24px;
          display: flex;
          flex-direction: column;
          gap: 16px;
        }

        .message {
          display: flex;
          gap: 12px;
          animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
          flex-direction: row-reverse;
        }

        .message-avatar {
          width: 36px;
          height: 36px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 18px;
          flex-shrink: 0;
        }

        .message.user .message-avatar {
          background: var(--gradient-primary);
          color: white;
        }

        .message.ai .message-avatar {
          background: var(--info-color);
          color: white;
        }

        .message-content {
          flex: 1;
          padding: 12px 16px;
          border-radius: 12px;
          max-width: 70%;
          line-height: 1.6;
        }

        .message.user .message-content {
          background: var(--gradient-primary);
          color: white;
          border-bottom-right-radius: 4px;
        }

        .message.ai .message-content {
          background: var(--bg-secondary);
          color: var(--text-primary);
          border: 1px solid var(--border-color);
          border-bottom-left-radius: 4px;
        }

        .message-text {
          font-size: 14px;
          margin-bottom: 8px;
        }

        .message-chart {
          margin-top: 12px;
          padding: 12px;
          background: var(--card-bg);
          border-radius: 8px;
          border: 1px solid var(--border-color);
        }

        .message-time {
          font-size: 11px;
          opacity: 0.7;
          margin-top: 4px;
        }

        .chat-input-container {
          padding: 20px 24px;
          border-top: 1px solid var(--border-color);
          background: var(--card-bg);
        }

        .chat-input-wrapper {
          display: flex;
          gap: 12px;
          align-items: flex-end;
        }

        .chat-input {
          flex: 1;
          padding: 12px 16px;
          border: 2px solid var(--border-color);
          border-radius: 12px;
          font-size: 14px;
          font-family: 'Inter', sans-serif;
          resize: none;
          min-height: 44px;
          max-height: 120px;
          background: var(--bg-secondary);
          color: var(--text-primary);
          transition: all 0.3s ease;
        }

        .chat-input:focus {
          outline: none;
          border-color: var(--primary-green);
          box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
        }

        .chat-send-btn {
          padding: 12px 24px;
          background: var(--gradient-primary);
          color: white;
          border: none;
          border-radius: 12px;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
          display: flex;
          align-items: center;
          gap: 8px;
          height: 44px;
        }

        .chat-send-btn:hover {
          transform: translateY(-2px);
          box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
        }

        .chat-send-btn:disabled {
          opacity: 0.6;
          cursor: not-allowed;
          transform: none;
        }

        .quick-actions {
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
          margin-top: 12px;
        }

        .quick-action-btn {
          padding: 8px 16px;
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 20px;
          font-size: 12px;
          color: var(--text-primary);
          cursor: pointer;
          transition: all 0.3s ease;
        }

        .quick-action-btn:hover {
          background: var(--hover-bg);
          border-color: var(--primary-green);
          color: var(--primary-green);
        }

        .prediction-card {
          margin-top: 12px;
          padding: 16px;
          background: var(--bg-secondary);
          border-radius: 8px;
          border-left: 4px solid var(--primary-green);
        }

        .prediction-title {
          font-weight: 600;
          color: var(--text-primary);
          margin-bottom: 8px;
          font-size: 15px;
        }

        .prediction-value {
          font-size: 24px;
          font-weight: 700;
          color: var(--primary-green);
          margin: 8px 0;
        }

        .prediction-details {
          font-size: 13px;
          color: var(--text-secondary);
          line-height: 1.6;
        }

        .loading-dots {
          display: inline-flex;
          gap: 4px;
        }

        .loading-dots span {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          background: var(--primary-green);
          animation: bounce 1.4s infinite ease-in-out both;
        }

        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
          0%, 80%, 100% { transform: scale(0); }
          40% { transform: scale(1); }
        }

        @media (max-width: 1200px) {
          .charts-section {
            grid-template-columns: 1fr;
          }
        }

        @media (max-width: 768px) {
          .sidebar {
            transform: translateX(-100%);
          }

          .sidebar.mobile-open {
            transform: translateX(0);
          }

          .main-content {
            margin-left: 0;
          }

          .header {
            padding: 0 16px;
          }

          .content {
            padding: 20px 16px;
          }

          .stats-grid {
            grid-template-columns: 1fr;
          }

          .profile-info {
            display: none;
          }
        }
    </style>
</head>
<body>
<div class="loading-overlay" id="loadingOverlay">
    <div class="loader"></div>
</div>

<div class="toast-container" id="toastContainer"></div>

<div class="dashboard-container">
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="logo">
                <img src="images/logo.jpeg" alt="AgriGuard AI Logo" style="width: 100%; height: 100%; object-fit: cover; border-radius: 12px;">
            </div>
            <div class="company-info">
                <div class="company-name">AgriGuard AI</div>
                <div class="company-tagline">Analytics Hub</div>
            </div>
        </div>

        <nav class="sidebar-nav">
            <div class="nav-section">
                <h3 class="nav-section-title">Analytics</h3>
                <ul class="nav-menu">
                    <li class="nav-item active">
                        <a class="nav-link" onclick="showSection('overview')">
                            <i class="fas fa-chart-line"></i>
                            <span>Overview</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" onclick="showSection('transactions')">
                            <i class="fas fa-exchange-alt"></i>
                            <span>Transactions</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" onclick="showSection('crops')">
                            <i class="fas fa-seedling"></i>
                            <span>Crop Production</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" onclick="showSection('market')">
                            <i class="fas fa-tags"></i>
                            <span>Market Prices</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" onclick="showSection('weather')">
                            <i class="fas fa-cloud-sun"></i>
                            <span>Weather Analysis</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" onclick="showSection('soil')">
                            <i class="fas fa-flask"></i>
                            <span>Soil Analysis</span>
                        </a>
                    </li>
                </ul>
            </div>

            <div class="nav-section">
                <h3 class="nav-section-title">AI Insights</h3>
                <ul class="nav-menu">
                    <li class="nav-item">
                        <a class="nav-link" onclick="showSection('predictions')">
                            <i class="fas fa-brain"></i>
                            <span>Predictions</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" onclick="showSection('recommendations')">
                            <i class="fas fa-lightbulb"></i>
                            <span>Recommendations</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" onclick="showSection('aiAssistant')">
                            <i class="fas fa-robot"></i>
                            <span>AI Assistant</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="http://localhost:1010/WhatsApp.html" target="_blank">
                            <i class="fas fa-comments"></i>
                            <span>WhatsApp Chat</span>
                        </a>
                    </li>
                </ul>
            </div>

            <div class="nav-section">
                <h3 class="nav-section-title">Reports</h3>
                <ul class="nav-menu">
                    <li class="nav-item">
                        <a class="nav-link" onclick="showSection('reports')">
                            <i class="fas fa-file-alt"></i>
                            <span>Generate Reports</span>
                        </a>
                    </li>
                </ul>
            </div>
        </nav>
    </div>

    <div class="main-content" id="mainContent">
        <header class="header">
            <div class="header-left">
                <button class="sidebar-toggle" onclick="toggleSidebar()">
                    <i class="fas fa-bars"></i>
                </button>
                <div class="greeting-section">
                    <div class="greeting-text" id="greetingText">Good Morning, Analyst!</div>
                    <div class="current-date" id="currentDate"></div>
                </div>
            </div>

            <div class="header-right">
                <button class="theme-toggle" onclick="toggleTheme()" id="themeToggle">
                    <i class="fas fa-moon"></i>
                    <span>Dark Mode</span>
                </button>
                <div class="profile-section">
                    <div class="profile-avatar" id="profileAvatar">A</div>
                    <div class="profile-info">
                        <div class="profile-name" id="profileName">Analyst</div>
                        <div class="profile-role" id="profileRole">Data Analyst</div>
                    </div>
                    <button class="logout-btn" onclick="handleLogout()" title="Logout">
                        <i class="fas fa-sign-out-alt"></i>
                    </button>
                </div>
            </div>
        </header>

        <main class="content">
            <!-- Overview Section -->
            <div id="overviewSection" class="content-section active">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-icon transactions">
                            <i class="fas fa-exchange-alt"></i>
                        </div>
                        <div class="stat-value" id="totalTransactions">0</div>
                        <div class="stat-label">Total Transactions</div>
                        <div class="stat-trend up" id="transactionsTrend">
                            <i class="fas fa-arrow-up"></i>
                            <span>0% vs last month</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <div class="stat-icon revenue">
                            <i class="fas fa-dollar-sign"></i>
                        </div>
                        <div class="stat-value" id="totalRevenue">RWF 0</div>
                        <div class="stat-label">Total Revenue</div>
                        <div class="stat-trend up" id="revenueTrend">
                            <i class="fas fa-arrow-up"></i>
                            <span>0% vs last month</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <div class="stat-icon farmers">
                            <i class="fas fa-users"></i>
                        </div>
                        <div class="stat-value" id="totalFarmers">0</div>
                        <div class="stat-label">Active Farmers</div>
                        <div class="stat-trend up" id="farmersTrend">
                            <i class="fas fa-arrow-up"></i>
                            <span>0% vs last month</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <div class="stat-icon buyers">
                            <i class="fas fa-shopping-cart"></i>
                        </div>
                        <div class="stat-value" id="totalBuyers">0</div>
                        <div class="stat-label">Active Buyers</div>
                        <div class="stat-trend up" id="buyersTrend">
                            <i class="fas fa-arrow-up"></i>
                            <span>0% vs last month</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <div class="stat-icon crops">
                            <i class="fas fa-seedling"></i>
                        </div>
                        <div class="stat-value" id="totalCrops">0</div>
                        <div class="stat-label">Crop Productions</div>
                        <div class="stat-trend up" id="cropsTrend">
                            <i class="fas fa-arrow-up"></i>
                            <span>0% vs last season</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <div class="stat-icon weather">
                            <i class="fas fa-cloud-sun"></i>
                        </div>
                        <div class="stat-value" id="avgTemperature">0Â°C</div>
                        <div class="stat-label">Avg Temperature</div>
                        <div class="stat-trend" id="temperatureTrend">
                            <i class="fas fa-minus"></i>
                            <span>Normal range</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <div class="stat-icon soil">
                            <i class="fas fa-flask"></i>
                        </div>
                        <div class="stat-value" id="avgSoilQuality">0%</div>
                        <div class="stat-label">Avg Soil Quality</div>
                        <div class="stat-trend up" id="soilTrend">
                            <i class="fas fa-arrow-up"></i>
                            <span>Excellent</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <div class="stat-icon market">
                            <i class="fas fa-tags"></i>
                        </div>
                        <div class="stat-value" id="avgMarketPrice">RWF 0</div>
                        <div class="stat-label">Avg Market Price</div>
                        <div class="stat-trend" id="priceTrend">
                            <i class="fas fa-minus"></i>
                            <span>Stable</span>
                        </div>
                    </div>
                </div>

                <div class="charts-section">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Transaction Trends (Last 12 Months)</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="transactionTrendChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Revenue Distribution</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="revenueDistributionChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Top Performing Crops</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="topCropsChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">User Growth Analysis</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="userGrowthChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="insights-grid">
                    <div class="insight-card positive">
                        <div class="insight-header">
                            <i class="insight-icon fas fa-check-circle" style="color: var(--success-color);"></i>
                            <div class="insight-title">Strong Transaction Volume</div>
                        </div>
                        <div class="insight-description">
                            Transaction volume has increased by <strong id="transactionIncrease">0%</strong> this month, indicating healthy market activity.
                        </div>
                    </div>

                    <div class="insight-card warning">
                        <div class="insight-header">
                            <i class="insight-icon fas fa-exclamation-triangle" style="color: var(--warning-color);"></i>
                            <div class="insight-title">Weather Alert</div>
                        </div>
                        <div class="insight-description">
                            Rainfall patterns show <strong id="rainfallStatus">variations</strong>. Farmers should monitor irrigation needs closely.
                        </div>
                    </div>

                    <div class="insight-card info">
                        <div class="insight-header">
                            <i class="insight-icon fas fa-info-circle" style="color: var(--info-color);"></i>
                            <div class="insight-title">Market Opportunity</div>
                        </div>
                        <div class="insight-description">
                            <strong id="highDemandCrop">Certain crops</strong> show high demand with increasing prices. Good selling opportunity.
                        </div>
                    </div>

                    <div class="insight-card positive">
                        <div class="insight-header">
                            <i class="insight-icon fas fa-leaf" style="color: var(--success-color);"></i>
                            <div class="insight-title">Soil Health Improving</div>
                        </div>
                        <div class="insight-description">
                            Average soil quality has improved by <strong id="soilImprovement">0%</strong> compared to last season.
                        </div>
                    </div>
                </div>
            </div>

            <!-- Transactions Section -->
            <div id="transactionsSection" class="content-section">
                <div class="charts-section">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Daily Transaction Volume</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="dailyTransactionsChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Transaction Status Distribution</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="transactionStatusChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Top 10 Buyers by Volume</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="topBuyersChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Top 10 Sellers by Revenue</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="topSellersChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Payment Method Distribution</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="paymentMethodChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Average Transaction Value Trend</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="avgTransactionValueChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="table-section">
                    <div class="table-header">
                        <h2 class="table-title">Recent Transactions</h2>
                        <div class="table-actions">
                            <button class="btn btn-secondary" onclick="refreshTransactions()">
                                <i class="fas fa-sync-alt"></i>
                                Refresh
                            </button>
                            <button class="btn btn-primary" onclick="exportTransactionsExcel()">
                                <i class="fas fa-file-excel"></i>
                                Export
                            </button>
                        </div>
                    </div>
                    <div style="overflow-x: auto;">
                        <table class="data-table">
                            <thead>
                            <tr>
                                <th>Transaction ID</th>
                                <th>Date</th>
                                <th>Farmer</th>
                                <th>Buyer</th>
                                <th>Crop</th>
                                <th>Quantity</th>
                                <th>Amount</th>
                                <th>Status</th>
                            </tr>
                            </thead>
                            <tbody id="transactionsTableBody">
                            <tr>
                                <td colspan="8" style="text-align: center; padding: 40px;">Loading transactions...</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Crop Production Section -->
            <div id="cropsSection" class="content-section">
                <div class="charts-section">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Production by Crop Type</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="cropProductionChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Yield Performance by Season</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="yieldSeasonChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Production Status Overview</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="productionStatusChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Area vs Yield Correlation</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="areaYieldScatterChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Monthly Harvest Volume</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="monthlyHarvestChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Organic vs Conventional Production</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="organicConventionalChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Market Prices Section -->
            <div id="marketSection" class="content-section">
                <div class="charts-section">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Price Trends by Crop</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="priceTrendsChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Market Type Price Comparison</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="marketTypeComparisonChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Demand vs Supply Analysis</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="demandSupplyChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Regional Price Variations</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="regionalPriceChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Price Volatility Index</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="priceVolatilityChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Seasonal Price Patterns</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="seasonalPriceChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Weather Analysis Section -->
            <div id="weatherSection" class="content-section">
                <div class="charts-section">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Temperature Trends</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="temperatureTrendChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Rainfall Distribution</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="rainfallChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Humidity Levels</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="humidityChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Wind Speed Analysis</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="windSpeedChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Weather Condition Distribution</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="weatherConditionChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Weather Impact on Crop Growth</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="weatherImpactChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Soil Analysis Section -->
            <div id="soilSection" class="content-section">
                <div class="charts-section">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">pH Level Distribution</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="phDistributionChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Soil Quality Trends</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="soilQualityTrendChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">NPK Nutrient Levels</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="npkLevelsChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Organic Matter Content</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="organicMatterChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Soil Texture Distribution</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="soilTextureChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Moisture Content Analysis</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="moistureContentChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- AI Predictions Section -->
            <div id="predictionsSection" class="content-section">
                <div class="ai-predictions-section">
                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-chart-line"></i>
                            </div>
                            <h3 class="prediction-title">Crop Yield Prediction</h3>
                        </div>
                        <div class="prediction-content" id="yieldPredictionContent">
                            Loading AI prediction...
                        </div>
                        <div class="prediction-metrics">
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Predicted Yield</div>
                                <div class="prediction-metric-value" id="predictedYield">0 tons</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Confidence</div>
                                <div class="prediction-metric-value" id="yieldConfidence">0%</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Expected Date</div>
                                <div class="prediction-metric-value" id="yieldDate">-</div>
                            </div>
                        </div>
                    </div>

                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-tags"></i>
                            </div>
                            <h3 class="prediction-title">Market Price Forecast</h3>
                        </div>
                        <div class="prediction-content" id="pricePredictionContent">
                            Loading AI prediction...
                        </div>
                        <div class="prediction-metrics">
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Forecasted Price</div>
                                <div class="prediction-metric-value" id="forecastedPrice">RWF 0</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Change</div>
                                <div class="prediction-metric-value" id="priceChange">0%</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Time Horizon</div>
                                <div class="prediction-metric-value" id="priceHorizon">30 days</div>
                            </div>
                        </div>
                    </div>

                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-cloud-rain"></i>
                            </div>
                            <h3 class="prediction-title">Weather Pattern Prediction</h3>
                        </div>
                        <div class="prediction-content" id="weatherPredictionContent">
                            Loading AI prediction...
                        </div>
                        <div class="prediction-metrics">
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Rainfall Forecast</div>
                                <div class="prediction-metric-value" id="rainfallForecast">0 mm</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Temperature</div>
                                <div class="prediction-metric-value" id="tempForecast">0Â°C</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Risk Level</div>
                                <div class="prediction-metric-value" id="weatherRisk">Low</div>
                            </div>
                        </div>
                    </div>

                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-flask"></i>
                            </div>
                            <h3 class="prediction-title">Soil Health Forecast</h3>
                        </div>
                        <div class="prediction-content" id="soilPredictionContent">
                            Loading AI prediction...
                        </div>
                        <div class="prediction-metrics">
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Health Score</div>
                                <div class="prediction-metric-value" id="soilHealthScore">0%</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Nutrient Status</div>
                                <div class="prediction-metric-value" id="nutrientStatus">Normal</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Action Needed</div>
                                <div class="prediction-metric-value" id="soilAction">None</div>
                            </div>
                        </div>
                    </div>

                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-users"></i>
                            </div>
                            <h3 class="prediction-title">User Activity Prediction</h3>
                        </div>
                        <div class="prediction-content" id="activityPredictionContent">
                            Loading AI prediction...
                        </div>
                        <div class="prediction-metrics">
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Expected Users</div>
                                <div class="prediction-metric-value" id="expectedUsers">0</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Peak Time</div>
                                <div class="prediction-metric-value" id="peakTime">-</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Growth Rate</div>
                                <div class="prediction-metric-value" id="growthRate">0%</div>
                            </div>
                        </div>
                    </div>

                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-exclamation-triangle"></i>
                            </div>
                            <h3 class="prediction-title">Risk Assessment</h3>
                        </div>
                        <div class="prediction-content" id="riskAssessmentContent">
                            Loading AI prediction...
                        </div>
                        <div class="prediction-metrics">
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Risk Level</div>
                                <div class="prediction-metric-value" id="overallRisk">Low</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Priority Areas</div>
                                <div class="prediction-metric-value" id="priorityAreas">0</div>
                            </div>
                            <div class="prediction-metric">
                                <div class="prediction-metric-label">Confidence</div>
                                <div class="prediction-metric-value" id="riskConfidence">0%</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Recommendations Section -->
            <div id="recommendationsSection" class="content-section">
                <div class="ai-predictions-section">
                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-seedling"></i>
                            </div>
                            <h3 class="prediction-title">Optimal Planting Recommendations</h3>
                        </div>
                        <div class="prediction-content" id="plantingRecommendations">
                            Loading recommendations...
                        </div>
                    </div>

                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-shopping-cart"></i>
                            </div>
                            <h3 class="prediction-title">Optimal Selling Strategy</h3>
                        </div>
                        <div class="prediction-content" id="sellingRecommendations">
                            Loading recommendations...
                        </div>
                    </div>

                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-tint"></i>
                            </div>
                            <h3 class="prediction-title">Irrigation Management</h3>
                        </div>
                        <div class="prediction-content" id="irrigationRecommendations">
                            Loading recommendations...
                        </div>
                    </div>

                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-spray-can"></i>
                            </div>
                            <h3 class="prediction-title">Fertilizer Application</h3>
                        </div>
                        <div class="prediction-content" id="fertilizerRecommendations">
                            Loading recommendations...
                        </div>
                    </div>

                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-bug"></i>
                            </div>
                            <h3 class="prediction-title">Pest Control Recommendations</h3>
                        </div>
                        <div class="prediction-content" id="pestRecommendations">
                            Loading recommendations...
                        </div>
                    </div>

                    <div class="ai-prediction-card">
                        <div class="prediction-header">
                            <div class="prediction-icon">
                                <i class="fas fa-chart-pie"></i>
                            </div>
                            <h3 class="prediction-title">Crop Diversification Strategy</h3>
                        </div>
                        <div class="prediction-content" id="diversificationRecommendations">
                            Loading recommendations...
                        </div>
                    </div>
                </div>
            </div>

            <!-- AI Assistant Section -->
            <div id="aiAssistantSection" class="content-section">
                <div class="ai-chat-container">
                    <div class="chat-header">
                        <div class="chat-header-icon">
                            <i class="fas fa-robot"></i>
                        </div>
                        <div>
                            <div class="chat-header-title">AI Prediction Assistant</div>
                            <div style="font-size: 12px; opacity: 0.9;">Powered by AgriGuard AI Analytics</div>
                        </div>
                    </div>

                    <div class="chat-messages" id="chatMessages">
                        <div class="message ai">
                            <div class="message-avatar">
                                <i class="fas fa-robot"></i>
                            </div>
                            <div class="message-content">
                                <div class="message-text">
                                    <strong>ð Welcome to AI Prediction Assistant!</strong><br><br>
                                    I can analyze your database and provide real-time predictions for:
                                    <ul style="margin: 8px 0; padding-left: 20px;">
                                        <li>ð¤ï¸ Weather patterns and forecasts</li>
                                        <li>ð± Soil health and quality trends</li>
                                        <li>ð¨âð¾ Farmer productivity and performance</li>
                                        <li>ð¾ Crop yields and production forecasts</li>
                                        <li>ð° Market price predictions</li>
                                        <li>ð§ Irrigation needs and recommendations</li>
                                        <li>ð½ï¸ Food security analysis</li>
                                        <li>ð Comprehensive trend analysis</li>
                                    </ul>
                                    <br>Ask me anything! For example: "Predict next month's weather" or "What's the market price forecast for maize?"
                                </div>
                                <div class="message-time">Just now</div>
                            </div>
                        </div>
                    </div>

                    <div class="chat-input-container">
                        <div class="quick-actions">
                            <button class="quick-action-btn" onclick="askQuickQuestion('weather')">
                                ð¤ï¸ Weather Prediction
                            </button>
                            <button class="quick-action-btn" onclick="askQuickQuestion('soil')">
                                ð± Soil Analysis
                            </button>
                            <button class="quick-action-btn" onclick="askQuickQuestion('market')">
                                ð° Market Forecast
                            </button>
                            <button class="quick-action-btn" onclick="askQuickQuestion('yield')">
                                ð¾ Crop Yield
                            </button>
                            <button class="quick-action-btn" onclick="askQuickQuestion('irrigation')">
                                ð§ Irrigation Needs
                            </button>
                            <button class="quick-action-btn" onclick="askQuickQuestion('security')">
                                ð½ï¸ Food Security
                            </button>
                            <button class="quick-action-btn" onclick="askQuickQuestion('comprehensive')">
                                ð Full Analysis
                            </button>
                        </div>
                        <div class="chat-input-wrapper">
                            <textarea
                                    id="chatInput"
                                    class="chat-input"
                                    placeholder="Ask about predictions, trends, or any analysis..."
                                    rows="1"
                                    onkeydown="handleChatInputKey(event)"
                            ></textarea>
                            <button id="chatSendBtn" class="chat-send-btn" onclick="sendChatMessage()">
                                <i class="fas fa-paper-plane"></i>
                                Send
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Reports Section -->
            <div id="reportsSection" class="content-section">
                <div class="chart-card" style="margin-bottom: 24px;">
                    <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 20px;">Report Configuration</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Report Type</label>
                            <select class="filter-select" id="reportType" style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 8px;">
                                <option value="comprehensive">Comprehensive Analysis</option>
                                <option value="transactions">Transaction Report</option>
                                <option value="crops">Crop Production Report</option>
                                <option value="market">Market Analysis Report</option>
                                <option value="weather">Weather Impact Report</option>
                                <option value="soil">Soil Health Report</option>
                                <option value="predictions">AI Predictions Report</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Time Period</label>
                            <select class="filter-select" id="reportPeriod" style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 8px;">
                                <option value="7">Last 7 Days</option>
                                <option value="30">Last 30 Days</option>
                                <option value="90">Last 90 Days</option>
                                <option value="365">Last Year</option>
                                <option value="custom">Custom Range</option>
                            </select>
                        </div>
                    </div>
                    <div style="display: flex; gap: 12px; margin-top: 20px;">
                        <button class="btn btn-primary" onclick="generatePDFReport()">
                            <i class="fas fa-file-pdf"></i>
                            Generate PDF Report
                        </button>
                        <button class="btn btn-secondary" onclick="generateExcelReport()">
                            <i class="fas fa-file-excel"></i>
                            Generate Excel Report
                        </button>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>

<script src="js/SessionTracker.js"></script>
<script src="js/user_session_handler.js"></script>
<script >



    // js/analyst_dashboard.js

// ==================== API CONFIGURATION ====================
const API_CONFIG = {
    TRANSACTIONS: 'http://localhost:1010/api/transactions',
    CROP_PRODUCTION: 'http://localhost:1010/api/v1/crop-productions',
    MARKET_PRICES: 'http://localhost:1010/api/market-prices',
    WEATHER: 'http://localhost:1010/api/weather-data',
    SOIL_DATA: 'http://localhost:1010/api/v1/soil-data',
    CROPS: 'http://localhost:1010/api/v1/crops',
    USERS: 'http://localhost:1010/api/users',
    FARMS: 'http://localhost:1010/api/farms'
};

// ==================== GLOBAL STATE ====================
let sessionHandler = null;
let currentUser = null;
let allTransactions = [];
let allCropProductions = [];
let allMarketPrices = [];
let allWeatherData = [];
let allSoilData = [];
let allCrops = [];
let charts = {};

// ==================== INITIALIZATION ====================
document.addEventListener('DOMContentLoaded', function() {
    if (!initializeSession()) return;

    initializeDashboard();
    updateDateTime();
    setInterval(updateDateTime, 60000);
    loadSavedTheme();
});

function initializeSession() {
    try {
        sessionHandler = UserSessionHandler.getInstance();
        currentUser = sessionHandler.getCurrentUser();

        if (!currentUser) {
            window.location.href = '/login.html';
            return false;
        }

        if (currentUser.role !== 'ANALYST') {
            showToast('Access denied. Analyst role required.', 'error');
            setTimeout(() => {
                sessionHandler.logout();
            }, 2000);
            return false;
        }

        updateUIWithUser();
        startSessionMonitoring();
        return true;
    } catch (error) {
        console.error('Session error:', error);
        window.location.href = '/login.html';
        return false;
    }
}

function updateUIWithUser() {
    if (!currentUser) return;

    const hour = new Date().getHours();
    let greeting = 'Good Morning';
    if (hour >= 12 && hour < 18) greeting = 'Good Afternoon';
    else if (hour >= 18) greeting = 'Good Evening';

    document.getElementById('greetingText').textContent = `${greeting}, ${currentUser.fullName}!`;
    document.getElementById('profileName').textContent = currentUser.fullName;
    document.getElementById('profileRole').textContent = 'Data Analyst';

    const initials = currentUser.fullName.split(' ').map(n => n[0]).join('').toUpperCase();
    document.getElementById('profileAvatar').textContent = initials;

    if (currentUser.photo || currentUser.profileImageUrl) {
        const photoUrl = currentUser.photo || currentUser.profileImageUrl;
        const avatar = document.getElementById('profileAvatar');
        avatar.style.backgroundImage = `url(${photoUrl})`;
        avatar.style.backgroundSize = 'cover';
        avatar.textContent = '';
    }
}

function startSessionMonitoring() {
    setInterval(() => {
        if (sessionHandler && sessionHandler.isAuthenticated()) {
            if (window.sessionTracker) {
                const userId = currentUser.userId || currentUser.id;
                window.sessionTracker.updateLastActivity(userId);
            }
        } else {
            handleSessionExpired();
        }
    }, 30000);

    ['click', 'keypress', 'mousemove', 'scroll'].forEach(eventType => {
        document.addEventListener(eventType, () => {
            if (currentUser && window.sessionTracker) {
                const userId = currentUser.userId || currentUser.id;
                window.sessionTracker.updateLastActivity(userId);
            }
        }, { passive: true });
    });
}

function handleSessionExpired() {
    showToast('Your session has expired. Please login again.', 'warning');
    setTimeout(() => {
        if (sessionHandler) {
            sessionHandler.logout();
        } else {
            window.location.href = '/login.html';
        }
    }, 2000);
}

function handleLogout() {
    if (confirm('Are you sure you want to logout?')) {
        if (currentUser && window.sessionTracker) {
            const userId = currentUser.userId || currentUser.id;
            window.sessionTracker.endSession(userId);
        }

        if (sessionHandler) {
            sessionHandler.logout();
        } else {
            window.location.href = '/login.html';
        }
    }
}


let allUsers = [];

// Ajoutez cette fonction de chargement
async function loadUsers() {
    try {
        const response = await fetch(`${API_CONFIG.USERS}?page=0&size=1000`);
        const data = await response.json();
        allUsers = data.content || data || [];
        console.log('Users loaded:', allUsers.length);
    } catch (error) {
        console.error('Error loading users:', error);
        allUsers = [];
    }
}


async function initializeDashboard() {
    showLoading(true);
    try {
        // Load all data first INCLUDING USERS
        await Promise.all([
            loadTransactions(),
            loadCropProductions(),
            loadMarketPrices(),
            loadWeatherData(),
            loadSoilData(),
            loadCrops(),
            loadUsers()  // â AJOUTEZ CETTE LIGNE
        ]);

        calculateStatistics();
        initializeAllCharts();

        setTimeout(() => {
            generateAIPredictions();
            generateAIRecommendations();
        }, 500);

        console.log('Dashboard initialized successfully');
    } catch (error) {
        console.error('Error initializing dashboard:', error);
        showToast('Error loading dashboard data', 'error');
    } finally {
        showLoading(false);
    }
}




// ==================== DATA LOADING FUNCTIONS ====================
async function loadTransactions() {
    try {
        // Load all pages since size is limited to 100
        let allData = [];
        let page = 0;
        let hasMore = true;

        while (hasMore && page < 50) { // Safety limit of 50 pages
            const response = await fetch(`${API_CONFIG.TRANSACTIONS}?page=${page}&size=100&sortBy=createdAt&sortDir=desc`);

            if (!response.ok) {
                console.error('Transaction API error:', response.status, response.statusText);
                break;
            }

            const data = await response.json();

            if (data.content && Array.isArray(data.content)) {
                allData = allData.concat(data.content);
                hasMore = !data.last && data.content.length > 0;
                page++;
            } else if (Array.isArray(data)) {
                allData = allData.concat(data);
                hasMore = false;
            } else {
                break;
            }
        }

        allTransactions = allData;
        console.log('Transactions loaded:', allTransactions.length);
    } catch (error) {
        console.error('Error loading transactions:', error);
        allTransactions = [];
    }
}

async function loadCropProductions() {
    try {
        const response = await fetch(`${API_CONFIG.CROP_PRODUCTION}/all`);
        const data = await response.json();
        allCropProductions = data.data || data || [];
        console.log('Crop productions loaded:', allCropProductions.length);
    } catch (error) {
        console.error('Error loading crop productions:', error);
        allCropProductions = [];
    }
}

async function loadMarketPrices() {
    try {
        const response = await fetch(API_CONFIG.MARKET_PRICES);

        if (!response.ok) {
            console.error('Market prices API error:', response.status);
            allMarketPrices = [];
            return;
        }

        const data = await response.json();

        // Handle different response formats
        if (Array.isArray(data)) {
            allMarketPrices = data;
        } else if (data.content && Array.isArray(data.content)) {
            allMarketPrices = data.content;
        } else if (data.data && Array.isArray(data.data)) {
            allMarketPrices = data.data;
        } else {
            console.error('Unexpected market prices response format:', data);
            allMarketPrices = [];
        }

        console.log('Market prices loaded:', allMarketPrices.length);
    } catch (error) {
        console.error('Error loading market prices:', error);
        allMarketPrices = [];
    }
}





async function loadWeatherData() {
    try {
        // Try the paginated endpoint first
        let allData = [];
        let page = 0;
        let hasMore = true;

        while (hasMore && page < 10) { // Limit to 10 pages to prevent infinite loops
            const response = await fetch(`${API_CONFIG.WEATHER}?page=${page}&size=100&sortBy=recordDate&sortDir=desc`);

            if (!response.ok) {
                console.error('Weather API error:', response.status);
                break;
            }

            const data = await response.json();

            // Handle the custom response format from your controller
            if (data.content && Array.isArray(data.content)) {
                allData = allData.concat(data.content);
                hasMore = data.hasNext;
                page++;
            } else {
                break;
            }
        }

        allWeatherData = allData;
        console.log('Weather data loaded:', allWeatherData.length);
    } catch (error) {
        console.error('Error loading weather data:', error);
        allWeatherData = [];
    }
}

async function loadSoilData() {
    try {
        const response = await fetch(`${API_CONFIG.SOIL_DATA}?page=0&size=1000`);
        const data = await response.json();
        allSoilData = data.content || data || [];
        console.log('Soil data loaded:', allSoilData.length);
    } catch (error) {
        console.error('Error loading soil data:', error);
        allSoilData = [];
    }
}

async function loadCrops() {
    try {
        const response = await fetch(`${API_CONFIG.CROPS}/all`);
        const data = await response.json();
        allCrops = data.data || data || [];
        console.log('Crops loaded:', allCrops.length);
    } catch (error) {
        console.error('Error loading crops:', error);
        allCrops = [];
    }
}

// ==================== STATISTICS CALCULATION ====================
function calculateStatistics() {
    const totalTransactions = allTransactions.length;
    const totalRevenue = allTransactions.reduce((sum, t) => sum + (parseFloat(t.totalAmount) || 0), 0);

    const uniqueFarmers = new Set(allTransactions.map(t => t.farmerId).filter(Boolean));
    const uniqueBuyers = new Set(allTransactions.map(t => t.buyerId).filter(Boolean));

    const avgTemp = allWeatherData.length > 0
        ? allWeatherData.reduce((sum, w) => sum + (parseFloat(w.temperature) || 0), 0) / allWeatherData.length
        : 0;

    const avgSoilQuality = calculateAverageSoilQuality();

    const avgPrice = allMarketPrices.length > 0
        ? allMarketPrices.reduce((sum, p) => sum + (parseFloat(p.pricePerKg) || 0), 0) / allMarketPrices.length
        : 0;

    document.getElementById('totalTransactions').textContent = totalTransactions;
    document.getElementById('totalRevenue').textContent = formatCurrency(totalRevenue);
    document.getElementById('totalFarmers').textContent = uniqueFarmers.size;
    document.getElementById('totalBuyers').textContent = uniqueBuyers.size;
    document.getElementById('totalCrops').textContent = allCropProductions.length;
    document.getElementById('avgTemperature').textContent = avgTemp.toFixed(1) + 'Â°C';
    document.getElementById('avgSoilQuality').textContent = avgSoilQuality.toFixed(0) + '%';
    document.getElementById('avgMarketPrice').textContent = formatCurrency(avgPrice);

    calculateTrends();
}

function calculateAverageSoilQuality() {
    if (allSoilData.length === 0) return 0;

    const scores = allSoilData.map(soil => {
        let score = 0;
        let maxScore = 0;

        if (soil.phLevel) {
            maxScore += 30;
            const ph = parseFloat(soil.phLevel);
            if (ph >= 6.0 && ph <= 7.5) score += 30;
            else if ((ph >= 5.5 && ph < 6.0) || (ph > 7.5 && ph <= 8.0)) score += 20;
            else score += 10;
        }

        if (soil.organicMatter) {
            maxScore += 25;
            const om = parseFloat(soil.organicMatter);
            if (om >= 5.0) score += 25;
            else if (om >= 3.0) score += 20;
            else if (om >= 2.0) score += 15;
            else score += 10;
        }

        if (soil.nitrogen && soil.phosphorus && soil.potassium) {
            maxScore += 25;
            const n = parseFloat(soil.nitrogen);
            const p = parseFloat(soil.phosphorus);
            const k = parseFloat(soil.potassium);
            if (n >= 40 && n <= 150) score += 8;
            if (p >= 25 && p <= 100) score += 8;
            if (k >= 150 && k <= 500) score += 9;
        }

        if (soil.porosity && soil.bulkDensity) {
            maxScore += 20;
            const porosity = parseFloat(soil.porosity);
            const bd = parseFloat(soil.bulkDensity);
            if (porosity > 40 && bd < 1.4) score += 20;
            else if (porosity > 30 && bd < 1.6) score += 15;
            else score += 10;
        }

        return maxScore > 0 ? (score * 100) / maxScore : 0;
    });

    return scores.reduce((a, b) => a + b, 0) / scores.length;
}

function calculateTrends() {
    const now = new Date();
    const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);

    const currentMonthTransactions = allTransactions.filter(t =>
        new Date(t.createdAt) >= lastMonth
    );
    const previousMonthStart = new Date(now.getFullYear(), now.getMonth() - 2, 1);
    const previousMonthEnd = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const previousMonthTransactions = allTransactions.filter(t => {
        const date = new Date(t.createdAt);
        return date >= previousMonthStart && date < previousMonthEnd;
    });

    const transactionGrowth = calculateGrowthRate(
        previousMonthTransactions.length,
        currentMonthTransactions.length
    );

    document.getElementById('transactionsTrend').innerHTML =
        `<i class="fas fa-arrow-${transactionGrowth >= 0 ? 'up' : 'down'}"></i>
        <span>${Math.abs(transactionGrowth).toFixed(1)}% vs last month</span>`;
    document.getElementById('transactionsTrend').className =
        `stat-trend ${transactionGrowth >= 0 ? 'up' : 'down'}`;

    const currentRevenue = currentMonthTransactions.reduce((sum, t) =>
        sum + (parseFloat(t.totalAmount) || 0), 0
    );
    const previousRevenue = previousMonthTransactions.reduce((sum, t) =>
        sum + (parseFloat(t.totalAmount) || 0), 0
    );
    const revenueGrowth = calculateGrowthRate(previousRevenue, currentRevenue);

    document.getElementById('revenueTrend').innerHTML =
        `<i class="fas fa-arrow-${revenueGrowth >= 0 ? 'up' : 'down'}"></i>
        <span>${Math.abs(revenueGrowth).toFixed(1)}% vs last month</span>`;
    document.getElementById('revenueTrend').className =
        `stat-trend ${revenueGrowth >= 0 ? 'up' : 'down'}`;

    document.getElementById('transactionIncrease').textContent =
        Math.abs(transactionGrowth).toFixed(1);
}

function calculateGrowthRate(previous, current) {
    if (previous === 0) return current > 0 ? 100 : 0;
    return ((current - previous) / previous) * 100;
}

// ==================== CHART INITIALIZATION ====================
function initializeAllCharts() {
    initializeTransactionTrendChart();
    initializeRevenueDistributionChart();
    initializeTopCropsChart();
    initializeUserGrowthChart();
    initializeDailyTransactionsChart();
    initializeTransactionStatusChart();
    initializeTopBuyersChart();
    initializeTopSellersChart();
    initializePaymentMethodChart();
    initializeAvgTransactionValueChart();
    initializeCropProductionChart();
    initializeYieldSeasonChart();
    initializeProductionStatusChart();
    initializeAreaYieldScatterChart();
    initializeMonthlyHarvestChart();
    initializeOrganicConventionalChart();
    initializePriceTrendsChart();
    initializeMarketTypeComparisonChart();
    initializeDemandSupplyChart();
    initializeRegionalPriceChart();
    initializePriceVolatilityChart();
    initializeSeasonalPriceChart();
    initializeTemperatureTrendChart();
    initializeRainfallChart();
    initializeHumidityChart();
    initializeWindSpeedChart();
    initializeWeatherConditionChart();
    initializeWeatherImpactChart();
    initializePhDistributionChart();
    initializeSoilQualityTrendChart();
    initializeNpkLevelsChart();
    initializeOrganicMatterChart();
    initializeSoilTextureChart();
    initializeMoistureContentChart();
}

function initializeTransactionTrendChart() {
    const ctx = document.getElementById('transactionTrendChart');
    if (!ctx) return;

    const monthlyData = getMonthlyTransactionData(12);

    charts.transactionTrend = new Chart(ctx, {
        type: 'line',
        data: {
            labels: monthlyData.labels,
            datasets: [{
                label: 'Transactions',
                data: monthlyData.counts,
                borderColor: '#22c55e',
                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                tension: 0.4,
                fill: true
            }, {
                label: 'Revenue (RWF)',
                data: monthlyData.revenue,
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                tension: 0.4,
                fill: true,
                yAxisID: 'y1'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            scales: {
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: { display: true, text: 'Transactions' }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: { display: true, text: 'Revenue (RWF)' },
                    grid: { drawOnChartArea: false }
                }
            }
        }
    });
}

function getMonthlyTransactionData(months) {
    const labels = [];
    const counts = [];
    const revenue = [];
    const now = new Date();

    for (let i = months - 1; i >= 0; i--) {
        const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const monthName = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
        labels.push(monthName);

        const monthTransactions = allTransactions.filter(t => {
            const tDate = new Date(t.createdAt);
            return tDate.getMonth() === date.getMonth() &&
                   tDate.getFullYear() === date.getFullYear();
        });

        counts.push(monthTransactions.length);
        revenue.push(monthTransactions.reduce((sum, t) =>
            sum + (parseFloat(t.totalAmount) || 0), 0
        ));
    }

    return { labels, counts, revenue };
}

function initializeRevenueDistributionChart() {
    const ctx = document.getElementById('revenueDistributionChart');
    if (!ctx) return;

    const cropRevenue = {};
    allTransactions.forEach(t => {
        const cropId = t.cropId || 'Unknown';
        cropRevenue[cropId] = (cropRevenue[cropId] || 0) + (parseFloat(t.totalAmount) || 0);
    });

    const sortedCrops = Object.entries(cropRevenue)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

    const labels = sortedCrops.map(([cropId]) => {
        const crop = allCrops.find(c => c.id === cropId);
        return crop ? crop.cropName : 'Unknown';
    });

    const data = sortedCrops.map(([, revenue]) => revenue);

    charts.revenueDistribution = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: data,
                backgroundColor: [
                    '#22c55e', '#3b82f6', '#f59e0b', '#ef4444',
                    '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'
                ]
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const label = context.label || '';
                            const value = context.parsed || 0;
                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                            const percentage = ((value / total) * 100).toFixed(1);
                            return `${label}: ${formatCurrency(value)} (${percentage}%)`;
                        }
                    }
                }
            }
        }
    });
}

function initializeTopCropsChart() {
    const ctx = document.getElementById('topCropsChart');
    if (!ctx) return;

    const cropProduction = {};
    allCropProductions.forEach(cp => {
        const cropId = cp.cropId || 'Unknown';
        const yield = parseFloat(cp.actualYield) || parseFloat(cp.expectedYield) || 0;
        cropProduction[cropId] = (cropProduction[cropId] || 0) + yield;
    });

    const sortedCrops = Object.entries(cropProduction)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

    const labels = sortedCrops.map(([cropId]) => {
        const crop = allCrops.find(c => c.id === cropId);
        return crop ? crop.cropName : 'Unknown';
    });

    const data = sortedCrops.map(([, production]) => production);

    charts.topCrops = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Total Production (tons)',
                data: data,
                backgroundColor: '#22c55e'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            scales: {
                x: { beginAtZero: true }
            }
        }
    });
}

function initializeUserGrowthChart() {
    const ctx = document.getElementById('userGrowthChart');
    if (!ctx) return;

    const monthlyData = getMonthlyUserData(12);

    charts.userGrowth = new Chart(ctx, {
        type: 'line',
        data: {
            labels: monthlyData.labels,
            datasets: [{
                label: 'Farmers',
                data: monthlyData.farmers,
                borderColor: '#22c55e',
                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                tension: 0.4,
                fill: true
            }, {
                label: 'Buyers',
                data: monthlyData.buyers,
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function getMonthlyUserData(months) {
    const labels = [];
    const farmers = [];
    const buyers = [];
    const now = new Date();

    for (let i = months - 1; i >= 0; i--) {
        const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const monthName = date.toLocaleDateString('en-US', { month: 'short' });
        labels.push(monthName);

        const monthTransactions = allTransactions.filter(t => {
            const tDate = new Date(t.createdAt);
            return tDate.getMonth() === date.getMonth() &&
                   tDate.getFullYear() === date.getFullYear();
        });

        const uniqueFarmers = new Set(monthTransactions.map(t => t.farmerId).filter(Boolean));
        const uniqueBuyers = new Set(monthTransactions.map(t => t.buyerId).filter(Boolean));

        farmers.push(uniqueFarmers.size);
        buyers.push(uniqueBuyers.size);
    }

    return { labels, farmers, buyers };
}

function initializeDailyTransactionsChart() {
    const ctx = document.getElementById('dailyTransactionsChart');
    if (!ctx) return;

    const last30Days = getLast30DaysData();

    charts.dailyTransactions = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: last30Days.labels,
            datasets: [{
                label: 'Daily Transactions',
                data: last30Days.counts,
                backgroundColor: '#22c55e'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function getLast30DaysData() {
    const labels = [];
    const counts = [];
    const now = new Date();

    for (let i = 29; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        labels.push(dateStr);

        const dayTransactions = allTransactions.filter(t => {
            const tDate = new Date(t.createdAt);
            return tDate.toDateString() === date.toDateString();
        });

        counts.push(dayTransactions.length);
    }

    return { labels, counts };
}

function initializeTransactionStatusChart() {
    const ctx = document.getElementById('transactionStatusChart');
    if (!ctx) return;

    const statusCounts = {};
    allTransactions.forEach(t => {
        const status = t.transactionStatus || 'UNKNOWN';
        statusCounts[status] = (statusCounts[status] || 0) + 1;
    });

    charts.transactionStatus = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: Object.keys(statusCounts).map(formatEnum),
            datasets: [{
                data: Object.values(statusCounts),
                backgroundColor: ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6']
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        }
    });
}

function initializeTopBuyersChart() {
    const ctx = document.getElementById('topBuyersChart');
    if (!ctx) return;

    const buyerStats = {};
    allTransactions.forEach(t => {
        const buyerId = t.buyerId || 'Unknown';
        if (!buyerStats[buyerId]) {
            buyerStats[buyerId] = { count: 0, amount: 0 };
        }
        buyerStats[buyerId].count++;
        buyerStats[buyerId].amount += parseFloat(t.totalAmount) || 0;
    });

    const sortedBuyers = Object.entries(buyerStats)
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 10);

    charts.topBuyers = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: sortedBuyers.map(([id]) => `Buyer ${id.substring(0, 8)}`),
            datasets: [{
                label: 'Transaction Count',
                data: sortedBuyers.map(([, stats]) => stats.count),
                backgroundColor: '#3b82f6'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            scales: {
                x: { beginAtZero: true }
            }
        }
    });
}

function initializeTopSellersChart() {
    const ctx = document.getElementById('topSellersChart');
    if (!ctx) return;

    const sellerStats = {};
    allTransactions.forEach(t => {
        const farmerId = t.farmerId || 'Unknown';
        if (!sellerStats[farmerId]) {
            sellerStats[farmerId] = { count: 0, amount: 0 };
        }
        sellerStats[farmerId].count++;
        sellerStats[farmerId].amount += parseFloat(t.totalAmount) || 0;
    });

    const sortedSellers = Object.entries(sellerStats)
        .sort((a, b) => b[1].amount - a[1].amount)
        .slice(0, 10);

    charts.topSellers = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: sortedSellers.map(([id]) => `Farmer ${id.substring(0, 8)}`),
            datasets: [{
                label: 'Total Revenue (RWF)',
                data: sortedSellers.map(([, stats]) => stats.amount),
                backgroundColor: '#22c55e'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            scales: {
                x: { beginAtZero: true }
            }
        }
    });
}

function initializePaymentMethodChart() {
    const ctx = document.getElementById('paymentMethodChart');
    if (!ctx) return;

    const methodCounts = {};
    allTransactions.forEach(t => {
        const method = t.paymentMethod || 'UNKNOWN';
        methodCounts[method] = (methodCounts[method] || 0) + 1;
    });

    charts.paymentMethod = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: Object.keys(methodCounts).map(formatEnum),
            datasets: [{
                data: Object.values(methodCounts),
                backgroundColor: ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6']
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        }
    });
}

function initializeAvgTransactionValueChart() {
    const ctx = document.getElementById('avgTransactionValueChart');
    if (!ctx) return;

    const monthlyAvg = getMonthlyAvgTransactionValue(12);

    charts.avgTransactionValue = new Chart(ctx, {
        type: 'line',
        data: {
            labels: monthlyAvg.labels,
            datasets: [{
                label: 'Avg Transaction Value (RWF)',
                data: monthlyAvg.values,
                borderColor: '#22c55e',
                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function getMonthlyAvgTransactionValue(months) {
    const labels = [];
    const values = [];
    const now = new Date();

    for (let i = months - 1; i >= 0; i--) {
        const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const monthName = date.toLocaleDateString('en-US', { month: 'short' });
        labels.push(monthName);

        const monthTransactions = allTransactions.filter(t => {
            const tDate = new Date(t.createdAt);
            return tDate.getMonth() === date.getMonth() &&
                   tDate.getFullYear() === date.getFullYear();
        });

        const avg = monthTransactions.length > 0
            ? monthTransactions.reduce((sum, t) => sum + (parseFloat(t.totalAmount) || 0), 0) / monthTransactions.length
            : 0;

        values.push(avg);
    }

    return { labels, values };
}

function initializeCropProductionChart() {
    const ctx = document.getElementById('cropProductionChart');
    if (!ctx) return;

    const cropCounts = {};
    allCropProductions.forEach(cp => {
        const cropId = cp.cropId || 'Unknown';
        cropCounts[cropId] = (cropCounts[cropId] || 0) + 1;
    });

    const sortedCrops = Object.entries(cropCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

    const labels = sortedCrops.map(([cropId]) => {
        const crop = allCrops.find(c => c.id === cropId);
        return crop ? crop.cropName : 'Unknown';
    });

    charts.cropProduction = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Production Count',
                data: sortedCrops.map(([, count]) => count),
                backgroundColor: '#22c55e'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeYieldSeasonChart() {
    const ctx = document.getElementById('yieldSeasonChart');
    if (!ctx) return;

    const seasonYield = {};
    allCropProductions.forEach(cp => {
        const season = cp.season || 'UNKNOWN';
        const yield = parseFloat(cp.actualYield) || parseFloat(cp.expectedYield) || 0;
        if (!seasonYield[season]) {
            seasonYield[season] = { total: 0, count: 0 };
        }
        seasonYield[season].total += yield;
        seasonYield[season].count++;
    });

    const seasons = Object.keys(seasonYield);
    const avgYields = seasons.map(s => seasonYield[s].total / seasonYield[s].count);

    charts.yieldSeason = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: seasons.map(formatEnum),
            datasets: [{
                label: 'Average Yield (tons/ha)',
                data: avgYields,
                backgroundColor: '#10b981'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeProductionStatusChart() {
    const ctx = document.getElementById('productionStatusChart');
    if (!ctx) return;

    const statusCounts = {};
    allCropProductions.forEach(cp => {
        const status = cp.productionStatus || 'UNKNOWN';
        statusCounts[status] = (statusCounts[status] || 0) + 1;
    });

    charts.productionStatus = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: Object.keys(statusCounts).map(formatEnum),
            datasets: [{
                data: Object.values(statusCounts),
                backgroundColor: ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6']
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        }
    });
}

function initializeAreaYieldScatterChart() {
    const ctx = document.getElementById('areaYieldScatterChart');
    if (!ctx) return;

    const scatterData = allCropProductions
        .filter(cp => cp.areaInHectares && (cp.actualYield || cp.expectedYield))
        .map(cp => ({
            x: parseFloat(cp.areaInHectares),
            y: parseFloat(cp.actualYield || cp.expectedYield)
        }));

    charts.areaYieldScatter = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                label: 'Area vs Yield',
                data: scatterData,
                backgroundColor: 'rgba(34, 197, 94, 0.6)',
                borderColor: '#22c55e'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: { display: true, text: 'Area (hectares)' },
                    beginAtZero: true
                },
                y: {
                    title: { display: true, text: 'Yield (tons/ha)' },
                    beginAtZero: true
                }
            }
        }
    });
}

function initializeMonthlyHarvestChart() {
    const ctx = document.getElementById('monthlyHarvestChart');
    if (!ctx) return;

    const monthlyHarvest = Array(12).fill(0);
    allCropProductions.forEach(cp => {
        if (cp.actualHarvestDate) {
            const month = new Date(cp.actualHarvestDate).getMonth();
            const yield = parseFloat(cp.actualYield) || 0;
            monthlyHarvest[month] += yield;
        }
    });

    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    charts.monthlyHarvest = new Chart(ctx, {
        type: 'line',
        data: {
            labels: monthNames,
            datasets: [{
                label: 'Harvest Volume (tons)',
                data: monthlyHarvest,
                borderColor: '#22c55e',
                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeOrganicConventionalChart() {
    const ctx = document.getElementById('organicConventionalChart');
    if (!ctx) return;

    const methodCounts = {};
    allCropProductions.forEach(cp => {
        const method = cp.productionMethod || 'UNKNOWN';
        methodCounts[method] = (methodCounts[method] || 0) + 1;
    });

    charts.organicConventional = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: Object.keys(methodCounts).map(formatEnum),
            datasets: [{
                data: Object.values(methodCounts),
                backgroundColor: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444']
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        }
    });
}

function initializePriceTrendsChart() {
    const ctx = document.getElementById('priceTrendsChart');
    if (!ctx) return;

    const topCrops = getTopCropsByPrice(5);
    const datasets = topCrops.map((crop, index) => {
        const colors = ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6'];
        return {
            label: crop.name,
            data: crop.prices,
            borderColor: colors[index],
            backgroundColor: `${colors[index]}20`,
            tension: 0.4,
            fill: true
        };
    });

    const labels = topCrops.length > 0 ? topCrops[0].dates : [];

    charts.priceTrends = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function getTopCropsByPrice(limit) {
    const cropPriceData = {};

    allMarketPrices.forEach(mp => {
        const cropId = mp.cropId || 'Unknown';
        if (!cropPriceData[cropId]) {
            cropPriceData[cropId] = [];
        }
        cropPriceData[cropId].push({
            date: mp.priceDate,
            price: parseFloat(mp.pricePerKg) || 0
        });
    });

    const topCrops = Object.entries(cropPriceData)
        .map(([cropId, prices]) => {
            const crop = allCrops.find(c => c.id === cropId);
            const sortedPrices = prices.sort((a, b) =>
                new Date(a.date) - new Date(b.date)
            ).slice(-30);

            return {
                cropId: cropId,
                name: crop ? crop.cropName : 'Unknown',
                dates: sortedPrices.map(p => new Date(p.date).toLocaleDateString('en-US',
                    { month: 'short', day: 'numeric' })),
                prices: sortedPrices.map(p => p.price),
                avgPrice: sortedPrices.reduce((sum, p) => sum + p.price, 0) / sortedPrices.length
            };
        })
        .sort((a, b) => b.avgPrice - a.avgPrice)
        .slice(0, limit);

    return topCrops;
}

function initializeMarketTypeComparisonChart() {
    const ctx = document.getElementById('marketTypeComparisonChart');
    if (!ctx) return;

    const typeAvgs = {};
    const typeCounts = {};

    allMarketPrices.forEach(mp => {
        const type = mp.marketType || 'UNKNOWN';
        if (!typeAvgs[type]) {
            typeAvgs[type] = 0;
            typeCounts[type] = 0;
        }
        typeAvgs[type] += parseFloat(mp.pricePerKg) || 0;
        typeCounts[type]++;
    });

    const types = Object.keys(typeAvgs);
    const avgPrices = types.map(type => typeAvgs[type] / typeCounts[type]);

    charts.marketTypeComparison = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: types.map(formatEnum),
            datasets: [{
                label: 'Average Price (RWF/kg)',
                data: avgPrices,
                backgroundColor: '#3b82f6'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeDemandSupplyChart() {
    const ctx = document.getElementById('demandSupplyChart');
    if (!ctx) return;

    const demandCounts = { LOW: 0, MEDIUM: 0, HIGH: 0, VERY_HIGH: 0 };
    const supplyCounts = { LOW: 0, MEDIUM: 0, HIGH: 0, EXCESS: 0 };

    allMarketPrices.forEach(mp => {
        const demand = mp.demandLevel || 'MEDIUM';
        const supply = mp.supplyLevel || 'MEDIUM';
        demandCounts[demand]++;
        supplyCounts[supply]++;
    });

    charts.demandSupply = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Low', 'Medium', 'High', 'Very High/Excess'],
            datasets: [{
                label: 'Demand',
                data: [demandCounts.LOW, demandCounts.MEDIUM, demandCounts.HIGH, demandCounts.VERY_HIGH],
                backgroundColor: '#22c55e'
            }, {
                label: 'Supply',
                data: [supplyCounts.LOW, supplyCounts.MEDIUM, supplyCounts.HIGH, supplyCounts.EXCESS],
                backgroundColor: '#3b82f6'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeRegionalPriceChart() {
    const ctx = document.getElementById('regionalPriceChart');
    if (!ctx) return;

    const locationAvgs = {};
    const locationCounts = {};

    allMarketPrices.forEach(mp => {
        const location = mp.location || 'Unknown';
        if (!locationAvgs[location]) {
            locationAvgs[location] = 0;
            locationCounts[location] = 0;
        }
        locationAvgs[location] += parseFloat(mp.pricePerKg) || 0;
        locationCounts[location]++;
    });

    const sortedLocations = Object.entries(locationAvgs)
        .map(([location, total]) => ({
            location,
            avg: total / locationCounts[location]
        }))
        .sort((a, b) => b.avg - a.avg)
        .slice(0, 10);

    charts.regionalPrice = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: sortedLocations.map(l => l.location),
            datasets: [{
                label: 'Average Price (RWF/kg)',
                data: sortedLocations.map(l => l.avg),
                backgroundColor: '#f59e0b'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            scales: {
                x: { beginAtZero: true }
            }
        }
    });
}

function initializePriceVolatilityChart() {
    const ctx = document.getElementById('priceVolatilityChart');
    if (!ctx) return;

    const cropVolatility = {};

    allCrops.forEach(crop => {
        const cropPrices = allMarketPrices
            .filter(mp => mp.cropId === crop.id)
            .map(mp => parseFloat(mp.pricePerKg) || 0);

        if (cropPrices.length > 1) {
            const avg = cropPrices.reduce((a, b) => a + b, 0) / cropPrices.length;
            const variance = cropPrices.reduce((sum, price) =>
                sum + Math.pow(price - avg, 2), 0) / cropPrices.length;
            const stdDev = Math.sqrt(variance);
            const cv = (stdDev / avg) * 100;
            cropVolatility[crop.cropName] = cv;
        }
    });

    const sortedVolatility = Object.entries(cropVolatility)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

    charts.priceVolatility = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: sortedVolatility.map(([name]) => name),
            datasets: [{
                label: 'Volatility Index (%)',
                data: sortedVolatility.map(([, volatility]) => volatility),
                backgroundColor: '#ef4444'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeSeasonalPriceChart() {
    const ctx = document.getElementById('seasonalPriceChart');
    if (!ctx) return;

    const monthlyPrices = Array(12).fill(0);
    const monthlyCounts = Array(12).fill(0);

    allMarketPrices.forEach(mp => {
        const month = new Date(mp.priceDate).getMonth();
        monthlyPrices[month] += parseFloat(mp.pricePerKg) || 0;
        monthlyCounts[month]++;
    });

    const avgPrices = monthlyPrices.map((total, i) =>
        monthlyCounts[i] > 0 ? total / monthlyCounts[i] : 0
    );

    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    charts.seasonalPrice = new Chart(ctx, {
        type: 'line',
        data: {
            labels: monthNames,
            datasets: [{
                label: 'Average Price (RWF/kg)',
                data: avgPrices,
                borderColor: '#22c55e',
                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeTemperatureTrendChart() {
    const ctx = document.getElementById('temperatureTrendChart');
    if (!ctx) return;

    const last30Days = getLast30DaysWeatherData('temperature');

    charts.temperatureTrend = new Chart(ctx, {
        type: 'line',
        data: {
            labels: last30Days.labels,
            datasets: [{
                label: 'Temperature (Â°C)',
                data: last30Days.values,
                borderColor: '#ef4444',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: false }
            }
        }
    });
}

function getLast30DaysWeatherData(field) {
    const labels = [];
    const values = [];
    const now = new Date();

    for (let i = 29; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        labels.push(dateStr);

        const dayWeather = allWeatherData.filter(w => {
            const wDate = new Date(w.measurementDate);
            return wDate.toDateString() === date.toDateString();
        });

        const avg = dayWeather.length > 0
            ? dayWeather.reduce((sum, w) => sum + (parseFloat(w[field]) || 0), 0) / dayWeather.length
            : 0;

        values.push(avg);
    }

    return { labels, values };
}

function initializeRainfallChart() {
    const ctx = document.getElementById('rainfallChart');
    if (!ctx) return;

    const last30Days = getLast30DaysWeatherData('rainfall');

    charts.rainfall = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: last30Days.labels,
            datasets: [{
                label: 'Rainfall (mm)',
                data: last30Days.values,
                backgroundColor: '#3b82f6'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeHumidityChart() {
    const ctx = document.getElementById('humidityChart');
    if (!ctx) return;

    const last30Days = getLast30DaysWeatherData('humidity');

    charts.humidity = new Chart(ctx, {
        type: 'line',
        data: {
            labels: last30Days.labels,
            datasets: [{
                label: 'Humidity (%)',
                data: last30Days.values,
                borderColor: '#06b6d4',
                backgroundColor: 'rgba(6, 182, 212, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100
                }
            }
        }
    });
}

function initializeWindSpeedChart() {
    const ctx = document.getElementById('windSpeedChart');
    if (!ctx) return;

    const last30Days = getLast30DaysWeatherData('windSpeed');

    charts.windSpeed = new Chart(ctx, {
        type: 'line',
        data: {
            labels: last30Days.labels,
            datasets: [{
                label: 'Wind Speed (m/s)',
                data: last30Days.values,
                borderColor: '#84cc16',
                backgroundColor: 'rgba(132, 204, 22, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeWeatherConditionChart() {
    const ctx = document.getElementById('weatherConditionChart');
    if (!ctx) return;

    const conditionCounts = {};
    allWeatherData.forEach(w => {
        const condition = w.weatherCondition || 'UNKNOWN';
        conditionCounts[condition] = (conditionCounts[condition] || 0) + 1;
    });

    charts.weatherCondition = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: Object.keys(conditionCounts).map(formatEnum),
            datasets: [{
                data: Object.values(conditionCounts),
                backgroundColor: ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899']
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        }
    });
}

function initializeWeatherImpactChart() {
    const ctx = document.getElementById('weatherImpactChart');
    if (!ctx) return;

    const optimalConditions = allWeatherData.filter(w => {
        const temp = parseFloat(w.temperature) || 0;
        const humidity = parseFloat(w.humidity) || 0;
        return temp >= 20 && temp <= 30 && humidity >= 40 && humidity <= 70;
    }).length;

    const totalConditions = allWeatherData.length;
    const subOptimal = totalConditions - optimalConditions;

    charts.weatherImpact = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: ['Optimal', 'Sub-optimal'],
            datasets: [{
                data: [optimalConditions, subOptimal],
                backgroundColor: ['#22c55e', '#f59e0b']
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        }
    });
}

function initializePhDistributionChart() {
    const ctx = document.getElementById('phDistributionChart');
    if (!ctx) return;

    const phCategories = {
        'Very Acidic (0-4.5)': 0,
        'Acidic (4.5-6.0)': 0,
        'Slightly Acidic (6.0-6.8)': 0,
        'Neutral (6.8-7.2)': 0,
        'Slightly Alkaline (7.2-8.0)': 0,
        'Alkaline (8.0-9.0)': 0,
        'Very Alkaline (>9.0)': 0
    };

    allSoilData.forEach(soil => {
        const ph = parseFloat(soil.phLevel);
        if (isNaN(ph)) return;

        if (ph < 4.5) phCategories['Very Acidic (0-4.5)']++;
        else if (ph < 6.0) phCategories['Acidic (4.5-6.0)']++;
        else if (ph < 6.8) phCategories['Slightly Acidic (6.0-6.8)']++;
        else if (ph < 7.2) phCategories['Neutral (6.8-7.2)']++;
        else if (ph < 8.0) phCategories['Slightly Alkaline (7.2-8.0)']++;
        else if (ph < 9.0) phCategories['Alkaline (8.0-9.0)']++;
        else phCategories['Very Alkaline (>9.0)']++;
    });

    charts.phDistribution = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: Object.keys(phCategories),
            datasets: [{
                label: 'Number of Samples',
                data: Object.values(phCategories),
                backgroundColor: ['#ef4444', '#f59e0b', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899']
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeSoilQualityTrendChart() {
    const ctx = document.getElementById('soilQualityTrendChart');
    if (!ctx) return;

    const monthlyQuality = getMonthlyAverageSoilQuality(12);

    charts.soilQualityTrend = new Chart(ctx, {
        type: 'line',
        data: {
            labels: monthlyQuality.labels,
            datasets: [{
                label: 'Average Soil Quality (%)',
                data: monthlyQuality.values,
                borderColor: '#22c55e',
                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100
                }
            }
        }
    });
}

function getMonthlyAverageSoilQuality(months) {
    const labels = [];
    const values = [];
    const now = new Date();

    for (let i = months - 1; i >= 0; i--) {
        const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const monthName = date.toLocaleDateString('en-US', { month: 'short' });
        labels.push(monthName);

        const monthSoil = allSoilData.filter(s => {
            const sDate = new Date(s.measurementDate || s.createdAt);
            return sDate.getMonth() === date.getMonth() &&
                   sDate.getFullYear() === date.getFullYear();
        });

        if (monthSoil.length > 0) {
            const scores = monthSoil.map(soil => calculateSoilQualityScore(soil));
            const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
            values.push(avg);
        } else {
            values.push(0);
        }
    }

    return { labels, values };
}

function calculateSoilQualityScore(soil) {
    let score = 0;
    let maxScore = 0;

    if (soil.phLevel) {
        maxScore += 30;
        const ph = parseFloat(soil.phLevel);
        if (ph >= 6.0 && ph <= 7.5) score += 30;
        else if ((ph >= 5.5 && ph < 6.0) || (ph > 7.5 && ph <= 8.0)) score += 20;
        else score += 10;
    }

    if (soil.organicMatter) {
        maxScore += 25;
        const om = parseFloat(soil.organicMatter);
        if (om >= 5.0) score += 25;
        else if (om >= 3.0) score += 20;
        else if (om >= 2.0) score += 15;
        else score += 10;
    }

    if (soil.nitrogen && soil.phosphorus && soil.potassium) {
        maxScore += 25;
        const n = parseFloat(soil.nitrogen);
        const p = parseFloat(soil.phosphorus);
        const k = parseFloat(soil.potassium);
        if (n >= 40 && n <= 150) score += 8;
        if (p >= 25 && p <= 100) score += 8;
        if (k >= 150 && k <= 500) score += 9;
    }

    if (soil.porosity && soil.bulkDensity) {
        maxScore += 20;
        const porosity = parseFloat(soil.porosity);
        const bd = parseFloat(soil.bulkDensity);
        if (porosity > 40 && bd < 1.4) score += 20;
        else if (porosity > 30 && bd < 1.6) score += 15;
        else score += 10;
    }

    return maxScore > 0 ? (score * 100) / maxScore : 0;
}

function initializeNpkLevelsChart() {
    const ctx = document.getElementById('npkLevelsChart');
    if (!ctx) return;

    const avgN = allSoilData.reduce((sum, s) => sum + (parseFloat(s.nitrogen) || 0), 0) / allSoilData.length;
    const avgP = allSoilData.reduce((sum, s) => sum + (parseFloat(s.phosphorus) || 0), 0) / allSoilData.length;
    const avgK = allSoilData.reduce((sum, s) => sum + (parseFloat(s.potassium) || 0), 0) / allSoilData.length;

    charts.npkLevels = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Nitrogen (N)', 'Phosphorus (P)', 'Potassium (K)'],
            datasets: [{
                label: 'Average Level (ppm)',
                data: [avgN, avgP, avgK],
                backgroundColor: ['#22c55e', '#3b82f6', '#f59e0b']
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeOrganicMatterChart() {
    const ctx = document.getElementById('organicMatterChart');
    if (!ctx) return;

    const omRanges = {
        '0-1%': 0,
        '1-2%': 0,
        '2-3%': 0,
        '3-5%': 0,
        '5-10%': 0,
        '>10%': 0
    };

    allSoilData.forEach(soil => {
        const om = parseFloat(soil.organicMatter);
        if (isNaN(om)) return;

        if (om < 1) omRanges['0-1%']++;
        else if (om < 2) omRanges['1-2%']++;
        else if (om < 3) omRanges['2-3%']++;
        else if (om < 5) omRanges['3-5%']++;
        else if (om < 10) omRanges['5-10%']++;
        else omRanges['>10%']++;
    });

    charts.organicMatter = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: Object.keys(omRanges),
            datasets: [{
                label: 'Number of Samples',
                data: Object.values(omRanges),
                backgroundColor: '#10b981'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

function initializeSoilTextureChart() {
    const ctx = document.getElementById('soilTextureChart');
    if (!ctx) return;

    const textureCounts = {};
    allSoilData.forEach(soil => {
        const texture = soil.soilTexture || 'UNKNOWN';
        textureCounts[texture] = (textureCounts[texture] || 0) + 1;
    });

    charts.soilTexture = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: Object.keys(textureCounts).map(formatEnum),
            datasets: [{
                data: Object.values(textureCounts),
                backgroundColor: ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444',
                                 '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16']
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        }
    });
}

function initializeMoistureContentChart() {
    const ctx = document.getElementById('moistureContentChart');
    if (!ctx) return;

    const moistureRanges = {
        'Very Dry (0-10%)': 0,
        'Dry (10-20%)': 0,
        'Normal (20-40%)': 0,
        'Moist (40-60%)': 0,
        'Very Moist (>60%)': 0
    };

    allSoilData.forEach(soil => {
        const moisture = parseFloat(soil.moisture);
        if (isNaN(moisture)) return;

        if (moisture < 10) moistureRanges['Very Dry (0-10%)']++;
        else if (moisture < 20) moistureRanges['Dry (10-20%)']++;
        else if (moisture < 40) moistureRanges['Normal (20-40%)']++;
        else if (moisture < 60) moistureRanges['Moist (40-60%)']++;
        else moistureRanges['Very Moist (>60%)']++;
    });

    charts.moistureContent = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: Object.keys(moistureRanges),
            datasets: [{
                label: 'Number of Samples',
                data: Object.values(moistureRanges),
                backgroundColor: ['#ef4444', '#f59e0b', '#22c55e', '#3b82f6', '#8b5cf6']
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}







// ==================== AI PREDICTIONS - UPDATED ====================
function generateAIPredictions() {
    // Generate all predictions with real data
    generateYieldPrediction();
    generatePricePrediction();
    generateWeatherPrediction();
    generateSoilPrediction();
    generateActivityPrediction();
    generateRiskAssessment();
}

// YIELD PREDICTION - Updated
function generateYieldPrediction() {
    const yieldContent = document.getElementById('yieldPredictionContent');
    const predictedYieldEl = document.getElementById('predictedYield');
    const yieldConfidenceEl = document.getElementById('yieldConfidence');
    const yieldDateEl = document.getElementById('yieldDate');

    if (allCropProductions.length === 0) {
        yieldContent.textContent = 'No crop production data available. Please add crop productions to generate predictions.';
        predictedYieldEl.textContent = '0 tons';
        yieldConfidenceEl.textContent = '0%';
        yieldDateEl.textContent = '-';
        return;
    }

    const harvestedProductions = allCropProductions.filter(cp =>
        cp.productionStatus === 'HARVESTED' && cp.actualYield
    );

    if (harvestedProductions.length === 0) {
        yieldContent.textContent = 'No harvested crop data available yet. Predictions will be available after first harvest.';
        predictedYieldEl.textContent = '0 tons';
        yieldConfidenceEl.textContent = '0%';
        yieldDateEl.textContent = '-';
        return;
    }

    // Calculate average yield from harvested crops
    const avgYield = harvestedProductions.reduce((sum, cp) =>
        sum + (parseFloat(cp.actualYield) || 0), 0
    ) / harvestedProductions.length;

    // Get active productions
    const activeProductions = allCropProductions.filter(cp =>
        cp.productionStatus === 'PLANTED' || cp.productionStatus === 'GROWING'
    );

    // Calculate total area
    const totalArea = activeProductions.reduce((sum, cp) =>
        sum + (parseFloat(cp.areaInHectares) || 0), 0
    );

    // Base prediction
    const basePrediction = avgYield * totalArea;

    // Adjust based on soil quality
    const avgSoilQuality = calculateAverageSoilQuality();
    const soilAdjustment = avgSoilQuality / 100;

    // Adjust based on weather
    const weatherScore = calculateWeatherScore();
    const weatherAdjustment = weatherScore / 100;

    // Final prediction
    const predictedYield = basePrediction * soilAdjustment * weatherAdjustment;

    // Calculate confidence based on data availability
    const dataPoints = harvestedProductions.length;
    const confidence = Math.min(95, 60 + (dataPoints / 10) * 10);

    // Calculate expected date
    const avgGrowthPeriod = harvestedProductions.reduce((sum, cp) => {
        if (cp.plantingDate && cp.actualHarvestDate) {
            const start = new Date(cp.plantingDate);
            const end = new Date(cp.actualHarvestDate);
            return sum + (end - start) / (1000 * 60 * 60 * 24);
        }
        return sum;
    }, 0) / harvestedProductions.length;

    const expectedDate = new Date();
    expectedDate.setDate(expectedDate.getDate() + (avgGrowthPeriod || 90));

    // Update UI
    yieldContent.textContent = `Based on analysis of ${harvestedProductions.length} historical harvests and current conditions ` +
        `(soil quality: ${avgSoilQuality.toFixed(0)}%, weather score: ${weatherScore.toFixed(0)}%), ` +
        `predicted yield for ${activeProductions.length} active productions across ${totalArea.toFixed(1)} hectares. ` +
        `Average historical yield: ${avgYield.toFixed(2)} tons/ha.`;

    predictedYieldEl.textContent = `${predictedYield.toFixed(1)} tons`;
    yieldConfidenceEl.textContent = `${confidence.toFixed(0)}%`;
    yieldDateEl.textContent = expectedDate.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
    });
}

// PRICE PREDICTION - Updated
function generatePricePrediction() {
    const priceContent = document.getElementById('pricePredictionContent');
    const forecastedPriceEl = document.getElementById('forecastedPrice');
    const priceChangeEl = document.getElementById('priceChange');
    const priceHorizonEl = document.getElementById('priceHorizon');

    if (allMarketPrices.length === 0) {
        priceContent.textContent = 'No market price data available. Please add market prices to generate forecasts.';
        forecastedPriceEl.textContent = 'RWF 0';
        priceChangeEl.textContent = '0%';
        priceHorizonEl.textContent = '30 days';
        return;
    }

    // Get recent prices (last 90 days)
    const recent = allMarketPrices
        .filter(mp => {
            const date = new Date(mp.priceDate);
            const now = new Date();
            const daysDiff = (now - date) / (1000 * 60 * 60 * 24);
            return daysDiff <= 90;
        })
        .sort((a, b) => new Date(b.priceDate) - new Date(a.priceDate));

    if (recent.length < 10) {
        priceContent.textContent = 'Insufficient recent market data (need at least 10 records). Please add more market prices.';
        forecastedPriceEl.textContent = 'RWF 0';
        priceChangeEl.textContent = '0%';
        return;
    }

    // Calculate average price
    const avgPrice = recent.reduce((sum, mp) =>
        sum + (parseFloat(mp.pricePerKg) || 0), 0
    ) / recent.length;

    // Calculate trend - compare last 30 days vs previous 30 days
    const last30 = recent.slice(0, 30);
    const avgLast30 = last30.reduce((sum, mp) =>
        sum + (parseFloat(mp.pricePerKg) || 0), 0
    ) / last30.length;

    const previous30 = recent.slice(30, 60);
    const avgPrevious30 = previous30.length > 0
        ? previous30.reduce((sum, mp) => sum + (parseFloat(mp.pricePerKg) || 0), 0) / previous30.length
        : avgLast30;

    const trend = avgPrevious30 > 0 ? ((avgLast30 - avgPrevious30) / avgPrevious30) * 100 : 0;

    // Analyze demand/supply
    const highDemandCount = recent.filter(mp =>
        mp.demandLevel === 'HIGH' || mp.demandLevel === 'VERY_HIGH'
    ).length;
    const demandRatio = highDemandCount / recent.length;

    // Calculate forecast
    const demandAdjustment = 1 + (demandRatio * 0.1);
    const trendAdjustment = 1 + (trend / 100) * 0.5;
    const forecastedPrice = avgPrice * demandAdjustment * trendAdjustment;
    const priceChange = ((forecastedPrice - avgPrice) / avgPrice) * 100;

    // Update UI
    priceContent.textContent = `Based on ${recent.length} recent market observations over the last 90 days. ` +
        `Current average price: ${formatCurrency(avgPrice)}/kg. ` +
        `High demand ratio: ${(demandRatio * 100).toFixed(0)}%. ` +
        `Market trend shows ${trend >= 0 ? 'upward' : 'downward'} momentum of ${Math.abs(trend).toFixed(1)}%.`;

    forecastedPriceEl.textContent = `${formatCurrency(forecastedPrice)}/kg`;
    priceChangeEl.textContent = `${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(1)}%`;
    priceChangeEl.style.color = priceChange >= 0 ? 'var(--success-color)' : 'var(--error-color)';
    priceHorizonEl.textContent = '30 days';
}

// WEATHER PREDICTION - Updated
function generateWeatherPrediction() {
    const weatherContent = document.getElementById('weatherPredictionContent');
    const rainfallForecastEl = document.getElementById('rainfallForecast');
    const tempForecastEl = document.getElementById('tempForecast');
    const weatherRiskEl = document.getElementById('weatherRisk');

    if (allWeatherData.length === 0) {
        weatherContent.textContent = 'No weather data available. Please add weather records to generate predictions.';
        rainfallForecastEl.textContent = '0 mm';
        tempForecastEl.textContent = '0Â°C';
        weatherRiskEl.textContent = 'Unknown';
        return;
    }

    // Get recent weather (last 14 days)
    const recent = allWeatherData
        .filter(w => {
            const date = new Date(w.measurementDate || w.recordDate);
            const now = new Date();
            const daysDiff = (now - date) / (1000 * 60 * 60 * 24);
            return daysDiff <= 14;
        })
        .sort((a, b) => new Date(b.measurementDate || b.recordDate) - new Date(a.measurementDate || a.recordDate));

    if (recent.length === 0) {
        weatherContent.textContent = 'No recent weather data available (last 14 days). Please add current weather records.';
        rainfallForecastEl.textContent = '0 mm';
        tempForecastEl.textContent = '0Â°C';
        weatherRiskEl.textContent = 'Unknown';
        return;
    }

    // Calculate averages
    const avgRainfall = recent.reduce((sum, w) =>
        sum + (parseFloat(w.rainfall) || 0), 0
    ) / recent.length;

    const avgTemp = recent.reduce((sum, w) =>
        sum + (parseFloat(w.temperature) || 0), 0
    ) / recent.length;

    // Calculate trends
    const last7 = recent.slice(0, 7);
    const rainfallLast7 = last7.reduce((sum, w) =>
        sum + (parseFloat(w.rainfall) || 0), 0
    ) / last7.length;

    const rainfallTrend = avgRainfall > 0
        ? ((rainfallLast7 - avgRainfall) / avgRainfall) * 100
        : 0;

    // Forecast
    const forecastRainfall = Math.max(0, avgRainfall * (1 + rainfallTrend / 200));

    // Risk assessment
    let riskLevel = 'Low';
    let riskColor = 'green';

    if (forecastRainfall > 20 || avgTemp > 35 || avgTemp < 15) {
        riskLevel = 'High';
        riskColor = 'red';
    } else if (forecastRainfall > 10 || avgTemp > 32 || avgTemp < 18) {
        riskLevel = 'Medium';
        riskColor = 'orange';
    }

    // Update UI
    weatherContent.textContent = `Analysis of ${recent.length} recent weather observations over the last 14 days. ` +
        `Rainfall trend is ${rainfallTrend >= 0 ? 'increasing' : 'decreasing'} by ${Math.abs(rainfallTrend).toFixed(1)}%. ` +
        `Temperature averaging ${avgTemp.toFixed(1)}Â°C. ` +
        `${riskLevel === 'High' ? 'Extreme weather indicators detected.' : 'Weather conditions are favorable.'}`;

    rainfallForecastEl.textContent = `${forecastRainfall.toFixed(1)} mm`;
    tempForecastEl.textContent = `${avgTemp.toFixed(1)}Â°C`;
    weatherRiskEl.textContent = riskLevel;
    weatherRiskEl.style.color = riskColor;
}

// SOIL PREDICTION - Updated
function generateSoilPrediction() {
    const soilContent = document.getElementById('soilPredictionContent');
    const soilHealthScoreEl = document.getElementById('soilHealthScore');
    const nutrientStatusEl = document.getElementById('nutrientStatus');
    const soilActionEl = document.getElementById('soilAction');

    if (allSoilData.length === 0) {
        soilContent.textContent = 'No soil data available. Please add soil analysis records to generate predictions.';
        soilHealthScoreEl.textContent = '0%';
        nutrientStatusEl.textContent = 'Unknown';
        soilActionEl.textContent = 'Add Data';
        return;
    }

    // Calculate average soil quality
    const avgQuality = calculateAverageSoilQuality();

    // Calculate NPK averages
    const avgN = allSoilData.reduce((sum, s) => sum + (parseFloat(s.nitrogen) || 0), 0) / allSoilData.length;
    const avgP = allSoilData.reduce((sum, s) => sum + (parseFloat(s.phosphorus) || 0), 0) / allSoilData.length;
    const avgK = allSoilData.reduce((sum, s) => sum + (parseFloat(s.potassium) || 0), 0) / allSoilData.length;

    // Assess nutrient status
    let nutrientStatus = 'Good';
    const issues = [];

    if (avgN < 40) {
        nutrientStatus = 'Low Nitrogen';
        issues.push('nitrogen');
    }
    if (avgP < 25) {
        nutrientStatus = issues.length > 0 ? 'Multiple Deficiencies' : 'Low Phosphorus';
        issues.push('phosphorus');
    }
    if (avgK < 150) {
        nutrientStatus = issues.length > 0 ? 'Multiple Deficiencies' : 'Low Potassium';
        issues.push('potassium');
    }

    // Determine action needed
    let actionNeeded = 'Monitor';
    if (avgQuality < 50) {
        actionNeeded = 'Urgent Intervention';
    } else if (avgQuality < 70) {
        actionNeeded = 'Improvement Needed';
    }

    // Update UI
    soilContent.textContent = `Based on ${allSoilData.length} soil samples. ` +
        `Average health score: ${avgQuality.toFixed(0)}%. ` +
        `NPK levels: N=${avgN.toFixed(1)}ppm, P=${avgP.toFixed(1)}ppm, K=${avgK.toFixed(1)}ppm. ` +
        (issues.length > 0
            ? `Deficiencies detected in ${issues.join(', ')}. `
            : 'All major nutrients within acceptable ranges. ') +
        `Recommended action: ${actionNeeded}.`;

    soilHealthScoreEl.textContent = `${avgQuality.toFixed(0)}%`;
    soilHealthScoreEl.style.color = avgQuality >= 70 ? 'var(--success-color)' : avgQuality >= 50 ? 'var(--warning-color)' : 'var(--error-color)';
    nutrientStatusEl.textContent = nutrientStatus;
    soilActionEl.textContent = actionNeeded;
}

// ACTIVITY PREDICTION - Updated
function generateActivityPrediction() {
    const activityContent = document.getElementById('activityPredictionContent');
    const expectedUsersEl = document.getElementById('expectedUsers');
    const peakTimeEl = document.getElementById('peakTime');
    const growthRateEl = document.getElementById('growthRate');

    if (allTransactions.length === 0) {
        activityContent.textContent = 'No transaction history available. Please add transactions to generate activity predictions.';
        expectedUsersEl.textContent = '0';
        peakTimeEl.textContent = '-';
        growthRateEl.textContent = '0%';
        return;
    }

    // Get transactions from last 30 days
    const last30Days = allTransactions.filter(t => {
        const date = new Date(t.createdAt);
        const now = new Date();
        const daysDiff = (now - date) / (1000 * 60 * 60 * 24);
        return daysDiff <= 30;
    });

    // Get transactions from previous 30 days
    const previous30Days = allTransactions.filter(t => {
        const date = new Date(t.createdAt);
        const now = new Date();
        const daysDiff = (now - date) / (1000 * 60 * 60 * 24);
        return daysDiff > 30 && daysDiff <= 60;
    });

    // Calculate unique users
    const uniqueFarmers = new Set(last30Days.map(t => t.farmerId).filter(Boolean));
    const uniqueBuyers = new Set(last30Days.map(t => t.buyerId).filter(Boolean));
    const totalUsers = uniqueFarmers.size + uniqueBuyers.size;

    // Calculate growth rate
    const growthRate = previous30Days.length > 0
        ? ((last30Days.length - previous30Days.length) / previous30Days.length) * 100
        : 0;

    // Predict next month
    const expectedUsers = Math.round(totalUsers * (1 + growthRate / 100));

    // Calculate peak hours
    const hourlyActivity = Array(24).fill(0);
    last30Days.forEach(t => {
        const hour = new Date(t.createdAt).getHours();
        hourlyActivity[hour]++;
    });

    const peakHour = hourlyActivity.indexOf(Math.max(...hourlyActivity));
    const peakTime = `${peakHour}:00 - ${peakHour + 1}:00`;

    // Update UI
    activityContent.textContent = `Analysis of ${last30Days.length} transactions over the last 30 days involving ${totalUsers} unique users. ` +
        `Activity growth rate of ${growthRate >= 0 ? '+' : ''}${growthRate.toFixed(1)}% compared to previous period. ` +
        `Peak activity hours identified for resource optimization.`;

    expectedUsersEl.textContent = expectedUsers;
    peakTimeEl.textContent = peakTime;
    growthRateEl.textContent = `${growthRate >= 0 ? '+' : ''}${growthRate.toFixed(1)}%`;
    growthRateEl.style.color = growthRate >= 0 ? 'var(--success-color)' : 'var(--error-color)';
}

// RISK ASSESSMENT - Updated
function generateRiskAssessment() {
    const riskContent = document.getElementById('riskAssessmentContent');
    const overallRiskEl = document.getElementById('overallRisk');
    const priorityAreasEl = document.getElementById('priorityAreas');
    const riskConfidenceEl = document.getElementById('riskConfidence');

    const risks = [];
    let riskScore = 0;

    // Weather risk
    if (allWeatherData.length > 0) {
        const recent = allWeatherData.slice(-14);
        const extremeWeather = recent.filter(w => {
            const temp = parseFloat(w.temperature) || 0;
            const rainfall = parseFloat(w.rainfall) || 0;
            return temp > 35 || temp < 15 || rainfall > 20;
        }).length;

        if (extremeWeather > 7) {
            risks.push('High extreme weather frequency');
            riskScore += 3;
        } else if (extremeWeather > 3) {
            risks.push('Moderate weather variability');
            riskScore += 1;
        }
    }

    // Soil risk
    const avgSoilQuality = calculateAverageSoilQuality();
    if (avgSoilQuality < 50) {
        risks.push('Critical soil health issues');
        riskScore += 3;
    } else if (avgSoilQuality < 70) {
        risks.push('Soil health below optimal');
        riskScore += 1;
    }

    // Market risk
    if (allMarketPrices.length > 0) {
        const recent = allMarketPrices.slice(-30);
        const prices = recent.map(mp => parseFloat(mp.pricePerKg) || 0);
        const avg = prices.reduce((a, b) => a + b, 0) / prices.length;
        const variance = prices.reduce((sum, p) => sum + Math.pow(p - avg, 2), 0) / prices.length;
        const stdDev = Math.sqrt(variance);
        const cv = (stdDev / avg) * 100;

        if (cv > 30) {
            risks.push('High market price volatility');
            riskScore += 2;
        } else if (cv > 15) {
            risks.push('Moderate price fluctuations');
            riskScore += 1;
        }
    }

    // Production risk
    if (allCropProductions.length > 0) {
        const overdue = allCropProductions.filter(cp => {
            if (cp.productionStatus === 'HARVESTED') return false;
            if (!cp.expectedHarvestDate) return false;
            return new Date(cp.expectedHarvestDate) < new Date();
        }).length;

        if (overdue > allCropProductions.length * 0.2) {
            risks.push('Significant harvest delays');
            riskScore += 2;
        } else if (overdue > 0) {
            risks.push('Some harvest delays detected');
            riskScore += 1;
        }
    }

    // Determine overall risk level
    let overallRisk = 'Low';
    if (riskScore >= 7) overallRisk = 'Critical';
    else if (riskScore >= 5) overallRisk = 'High';
    else if (riskScore >= 3) overallRisk = 'Medium';

    // Calculate confidence
    const dataAvailability = [
        allWeatherData.length > 0,
        allSoilData.length > 0,
        allMarketPrices.length > 0,
        allCropProductions.length > 0,
        allTransactions.length > 0
    ].filter(Boolean).length;

    const confidence = Math.min(90, 60 + (dataAvailability / 5) * 30);

    // Update UI
    const riskContentText = risks.length > 0
        ? `Identified ${risks.length} risk factors: ${risks.join('; ')}. ` +
          `Comprehensive risk analysis based on ${dataAvailability} data sources. ` +
          `Immediate attention recommended for high-priority areas.`
        : `No significant risks identified. All monitored parameters within acceptable ranges. ` +
          `Continue regular monitoring and maintain current best practices.`;

    riskContent.textContent = riskContentText;
    overallRiskEl.textContent = overallRisk;
    priorityAreasEl.textContent = risks.length;
    riskConfidenceEl.textContent = `${confidence.toFixed(0)}%`;

    const riskColors = {
        'Low': 'green',
        'Medium': 'orange',
        'High': 'red',
        'Critical': 'darkred'
    };
    overallRiskEl.style.color = riskColors[overallRisk];
}























// ==================== AI RECOMMENDATIONS ====================
function generateAIRecommendations() {
    generatePlantingRecommendations();
    generateSellingRecommendations();
    generateIrrigationRecommendations();
    generateFertilizerRecommendations();
    generatePestRecommendations();
    generateDiversificationRecommendations();
}

function generatePlantingRecommendations() {
    if (allCropProductions.length === 0 || allCrops.length === 0) {
        document.getElementById('plantingRecommendations').textContent =
            'Insufficient data for planting recommendations.';
        return;
    }

    const cropPerformance = {};
    allCropProductions.forEach(cp => {
        if (cp.actualYield) {
            const cropId = cp.cropId;
            if (!cropPerformance[cropId]) {
                cropPerformance[cropId] = { yields: [], count: 0 };
            }
            cropPerformance[cropId].yields.push(parseFloat(cp.actualYield));
            cropPerformance[cropId].count++;
        }
    });

    const cropAvgYield = {};
    Object.keys(cropPerformance).forEach(cropId => {
        const yields = cropPerformance[cropId].yields;
        cropAvgYield[cropId] = yields.reduce((a, b) => a + b, 0) / yields.length;
    });

    const sortedCrops = Object.entries(cropAvgYield)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

    const recommendations = sortedCrops.map(([cropId, avgYield]) => {
        const crop = allCrops.find(c => c.id === cropId);
        const cropName = crop ? crop.cropName : 'Unknown';
        return `${cropName} (avg yield: ${avgYield.toFixed(1)} t/ha)`;
    });

    const currentSeason = getCurrentSeason();
    const avgSoilQuality = calculateAverageSoilQuality();

    let soilAdvice = '';
    if (avgSoilQuality < 60) {
        soilAdvice = ' Consider soil amendment before planting.';
    }

    document.getElementById('plantingRecommendations').innerHTML =
        `<strong>Current Season:</strong> ${currentSeason}<br><br>` +
        `<strong>Top performing crops based on historical yield:</strong><br>` +
        `${recommendations.map((r, i) => `${i + 1}. ${r}`).join('<br>')}<br><br>` +
        `<strong>Soil Status:</strong> Average quality ${avgSoilQuality.toFixed(0)}%.${soilAdvice}<br><br>` +
        `<strong>Recommendation:</strong> Focus on proven high-yield crops for this region. ` +
        `Consider crop rotation to maintain soil health. Monitor weather forecasts for optimal planting windows.`;
}

function getCurrentSeason() {
    const month = new Date().getMonth();
    if (month >= 2 && month <= 4) return 'Spring (March-May)';
    if (month >= 5 && month <= 7) return 'Summer (June-August)';
    if (month >= 8 && month <= 10) return 'Fall (September-November)';
    return 'Winter (December-February)';
}

function generateSellingRecommendations() {
    if (allMarketPrices.length === 0) {
        document.getElementById('sellingRecommendations').textContent =
            'Insufficient market data for selling recommendations.';
        return;
    }

    const cropPrices = {};
    allMarketPrices.forEach(mp => {
        const cropId = mp.cropId;
        if (!cropPrices[cropId]) {
            cropPrices[cropId] = [];
        }
        cropPrices[cropId].push(parseFloat(mp.pricePerKg) || 0);
    });

    const cropAvgPrices = {};
    Object.keys(cropPrices).forEach(cropId => {
        const prices = cropPrices[cropId];
        cropAvgPrices[cropId] = prices.reduce((a, b) => a + b, 0) / prices.length;
    });

    const sortedCrops = Object.entries(cropAvgPrices)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

    const recommendations = sortedCrops.map(([cropId, avgPrice]) => {
        const crop = allCrops.find(c => c.id === cropId);
        const cropName = crop ? crop.cropName : 'Unknown';

        const recentPrices = allMarketPrices
            .filter(mp => mp.cropId === cropId)
            .slice(-10)
            .map(mp => parseFloat(mp.pricePerKg) || 0);

        const recentAvg = recentPrices.reduce((a, b) => a + b, 0) / recentPrices.length;
        const trend = recentAvg > avgPrice ? 'â' : recentAvg < avgPrice ? 'â' : 'â';

        return `${cropName}: ${formatCurrency(avgPrice)}/kg ${trend}`;
    });

    const highDemandCrops = allMarketPrices
        .filter(mp => mp.demandLevel === 'HIGH' || mp.demandLevel === 'VERY_HIGH')
        .map(mp => {
            const crop = allCrops.find(c => c.id === mp.cropId);
            return crop ? crop.cropName : 'Unknown';
        });

    const uniqueHighDemand = [...new Set(highDemandCrops)].slice(0, 3);

    document.getElementById('sellingRecommendations').innerHTML =
        `<strong>Top Priced Crops:</strong><br>` +
        `${recommendations.map((r, i) => `${i + 1}. ${r}`).join('<br>')}<br><br>` +
        `<strong>High Demand Crops:</strong><br>` +
        `${uniqueHighDemand.join(', ') || 'No specific high demand detected'}<br><br>` +
        `<strong>Strategy:</strong> Best selling window is typically early morning for wholesale markets. ` +
        `Consider direct buyer relationships for premium prices. Quality grading significantly impacts final price. ` +
        `Monitor daily price fluctuations and sell during price peaks.`;
}

function generateIrrigationRecommendations() {
    if (allWeatherData.length === 0 || allSoilData.length === 0) {
        document.getElementById('irrigationRecommendations').textContent =
            'Insufficient weather and soil data for irrigation recommendations.';
        return;
    }

    const recent = allWeatherData
        .filter(w => {
            const date = new Date(w.measurementDate);
            const now = new Date();
            const daysDiff = (now - date) / (1000 * 60 * 60 * 24);
            return daysDiff <= 7;
        });

    const totalRainfall = recent.reduce((sum, w) =>
        sum + (parseFloat(w.rainfall) || 0), 0
    );

    const avgMoisture = allSoilData.reduce((sum, s) =>
        sum + (parseFloat(s.moisture) || 0), 0
    ) / allSoilData.length;

    let recommendation = '';
    let urgency = '';

    if (totalRainfall < 10 && avgMoisture < 20) {
        recommendation = 'URGENT: Increase irrigation frequency. Soil moisture critically low.';
        urgency = 'High Priority';
    } else if (totalRainfall < 20 && avgMoisture < 30) {
        recommendation = 'Moderate irrigation needed. Schedule additional watering sessions.';
        urgency = 'Medium Priority';
    } else if (totalRainfall > 50 || avgMoisture > 60) {
        recommendation = 'Reduce or pause irrigation. Excessive moisture may harm crops.';
        urgency = 'Monitor Closely';
    } else {
        recommendation = 'Current irrigation schedule appears adequate. Continue monitoring.';
        urgency = 'Low Priority';
    }

    const avgTemp = recent.reduce((sum, w) =>
        sum + (parseFloat(w.temperature) || 0), 0
    ) / recent.length;

    let tempAdjustment = '';
    if (avgTemp > 30) {
        tempAdjustment = ' High temperatures increase evaporation - consider early morning or evening irrigation.';
    }

    document.getElementById('irrigationRecommendations').innerHTML =
        `<strong>7-Day Rainfall:</strong> ${totalRainfall.toFixed(1)}mm<br>` +
        `<strong>Avg Soil Moisture:</strong> ${avgMoisture.toFixed(1)}%<br>` +
        `<strong>Avg Temperature:</strong> ${avgTemp.toFixed(1)}Â°C<br><br>` +
        `<strong>Urgency Level:</strong> ${urgency}<br><br>` +
        `<strong>Recommendation:</strong> ${recommendation}${tempAdjustment}<br><br>` +
        `<strong>Best Practices:</strong> Use drip irrigation for efficiency. Water deeply but less frequently. ` +
        `Monitor soil moisture at root depth. Mulching reduces water loss.`;
}

function generateFertilizerRecommendations() {
    if (allSoilData.length === 0) {
        document.getElementById('fertilizerRecommendations').textContent =
            'Insufficient soil data for fertilizer recommendations.';
        return;
    }

    const avgN = allSoilData.reduce((sum, s) => sum + (parseFloat(s.nitrogen) || 0), 0) / allSoilData.length;
    const avgP = allSoilData.reduce((sum, s) => sum + (parseFloat(s.phosphorus) || 0), 0) / allSoilData.length;
    const avgK = allSoilData.reduce((sum, s) => sum + (parseFloat(s.potassium) || 0), 0) / allSoilData.length;
    const avgOM = allSoilData.reduce((sum, s) => sum + (parseFloat(s.organicMatter) || 0), 0) / allSoilData.length;

    const deficiencies = [];
    let npkRatio = '';

    if (avgN < 40) {
        deficiencies.push('Nitrogen');
        npkRatio = 'High N (e.g., 20-10-10)';
    } else if (avgP < 25) {
        deficiencies.push('Phosphorus');
        npkRatio = 'High P (e.g., 10-20-10)';
    } else if (avgK < 150) {
        deficiencies.push('Potassium');
        npkRatio = 'High K (e.g., 10-10-20)';
    } else {
        npkRatio = 'Balanced (e.g., 10-10-10)';
    }

    let organicRecommendation = '';
    if (avgOM < 3) {
        organicRecommendation = ' Add compost or manure (2-3 tons/hectare) to improve organic matter.';
    }

    const applicationTiming = allCropProductions.filter(cp =>
        cp.productionStatus === 'PLANTED' || cp.productionStatus === 'GROWING'
    ).length > 0
        ? 'Apply fertilizer during active growth phase. Split applications for better nutrient uptake.'
        : 'Prepare soil with fertilizer before planting season.';

    document.getElementById('fertilizerRecommendations').innerHTML =
        `<strong>Current NPK Levels:</strong><br>` +
        `Nitrogen: ${avgN.toFixed(1)} ppm<br>` +
        `Phosphorus: ${avgP.toFixed(1)} ppm<br>` +
        `Potassium: ${avgK.toFixed(1)} ppm<br>` +
        `Organic Matter: ${avgOM.toFixed(1)}%<br><br>` +
        (deficiencies.length > 0
            ? `<strong>Deficiencies Detected:</strong> ${deficiencies.join(', ')}<br><br>`
            : `<strong>Status:</strong> Nutrient levels adequate<br><br>`) +
        `<strong>Recommended NPK Ratio:</strong> ${npkRatio}<br><br>` +
        `<strong>Application Guidance:</strong> ${applicationTiming}${organicRecommendation}<br><br>` +
        `<strong>Important:</strong> Conduct soil tests every 6 months. Avoid over-fertilization which can harm crops and environment.`;
}

function generatePestRecommendations() {
    const recentWeather = allWeatherData
        .filter(w => {
            const date = new Date(w.measurementDate);
            const now = new Date();
            const daysDiff = (now - date) / (1000 * 60 * 60 * 24);
            return daysDiff <= 14;
        });

    if (recentWeather.length === 0) {
        document.getElementById('pestRecommendations').textContent =
            'Insufficient recent weather data for pest risk assessment.';
        return;
    }

    const avgTemp = recentWeather.reduce((sum, w) =>
        sum + (parseFloat(w.temperature) || 0), 0
    ) / recentWeather.length;

    const avgHumidity = recentWeather.reduce((sum, w) =>
        sum + (parseFloat(w.humidity) || 0), 0
    ) / recentWeather.length;

    const totalRainfall = recentWeather.reduce((sum, w) =>
        sum + (parseFloat(w.rainfall) || 0), 0
    );

    let riskLevel = 'Low';
    const riskFactors = [];

    if (avgTemp > 25 && avgTemp < 30 && avgHumidity > 60) {
        riskLevel = 'High';
        riskFactors.push('Optimal conditions for fungal diseases');
    }

    if (avgTemp > 28 && avgHumidity < 50) {
        riskLevel = 'Medium';
        riskFactors.push('Favorable for aphids and spider mites');
    }

    if (totalRainfall > 100) {
        riskLevel = 'Medium';
        riskFactors.push('Excess moisture increases disease pressure');
    }

    const recommendations = [];
    if (riskLevel === 'High') {
        recommendations.push('Conduct daily field inspections');
        recommendations.push('Apply preventive organic pesticides');
        recommendations.push('Improve air circulation between plants');
    } else if (riskLevel === 'Medium') {
        recommendations.push('Monitor crops every 2-3 days');
        recommendations.push('Have treatment options ready');
        recommendations.push('Remove infected plants promptly');
    } else {
        recommendations.push('Continue weekly monitoring');
        recommendations.push('Maintain good field hygiene');
        recommendations.push('Encourage beneficial insects');
    }

    document.getElementById('pestRecommendations').innerHTML =
        `<strong>Risk Assessment (14-day outlook):</strong><br>` +
        `Temperature: ${avgTemp.toFixed(1)}Â°C<br>` +
        `Humidity: ${avgHumidity.toFixed(1)}%<br>` +
        `Total Rainfall: ${totalRainfall.toFixed(1)}mm<br><br>` +
        `<strong>Pest Risk Level:</strong> ${riskLevel}<br><br>` +
        (riskFactors.length > 0
            ? `<strong>Risk Factors:</strong><br>${riskFactors.map(r => `â¢ ${r}`).join('<br>')}<br><br>`
            : '') +
        `<strong>Recommended Actions:</strong><br>` +
        `${recommendations.map(r => `â¢ ${r}`).join('<br>')}<br><br>` +
        `<strong>Integrated Pest Management:</strong> Combine biological, cultural, and chemical controls. ` +
        `Prioritize organic and least-toxic options. Rotate pesticides to prevent resistance.`;
}

function generateDiversificationRecommendations() {
    if (allCropProductions.length === 0 || allCrops.length === 0) {
        document.getElementById('diversificationRecommendations').textContent =
            'Insufficient data for diversification recommendations.';
        return;
    }

    const cropCounts = {};
    allCropProductions.forEach(cp => {
        const cropId = cp.cropId;
        cropCounts[cropId] = (cropCounts[cropId] || 0) + 1;
    });

    const totalProductions = allCropProductions.length;
    const uniqueCrops = Object.keys(cropCounts).length;
    const diversificationRatio = uniqueCrops / totalProductions;

    let diversificationLevel = '';
    let recommendation = '';

    if (diversificationRatio > 0.3) {
        diversificationLevel = 'High';
        recommendation = 'Excellent crop diversification. Continue monitoring performance of each crop type.';
    } else if (diversificationRatio > 0.15) {
        diversificationLevel = 'Moderate';
        recommendation = 'Good diversification. Consider adding 1-2 more crop varieties to spread risk.';
    } else {
        diversificationLevel = 'Low';
        recommendation = 'Low diversification detected. High dependency on few crops increases risk. Strongly recommend expanding crop portfolio.';
    }

    const topCrops = Object.entries(cropCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([cropId, count]) => {
            const crop = allCrops.find(c => c.id === cropId);
            const cropName = crop ? crop.cropName : 'Unknown';
            const percentage = ((count / totalProductions) * 100).toFixed(1);
            return `${cropName}: ${percentage}%`;
        });

    const underrepresentedCrops = allCrops
        .filter(crop => !cropCounts[crop.id])
        .slice(0, 5)
        .map(crop => crop.cropName);

    document.getElementById('diversificationRecommendations').innerHTML =
        `<strong>Current Diversification:</strong><br>` +
        `${uniqueCrops} different crops across ${totalProductions} productions<br>` +
        `Level: ${diversificationLevel}<br><br>` +
        `<strong>Current Crop Distribution:</strong><br>` +
        `${topCrops.join('<br>')}<br><br>` +
        `<strong>Assessment:</strong> ${recommendation}<br><br>` +
        (underrepresentedCrops.length > 0
            ? `<strong>Consider Adding:</strong><br>${underrepresentedCrops.join(', ')}<br><br>`
            : '') +
        `<strong>Benefits of Diversification:</strong><br>` +
        `â¢ Reduces financial risk from crop failure<br>` +
        `â¢ Improves soil health through crop rotation<br>` +
        `â¢ Provides multiple income streams<br>` +
        `â¢ Better resilience to market price fluctuations<br>` +
        `â¢ Natural pest and disease management`;
}

// ==================== TRANSACTION TABLE ====================
async function refreshTransactions() {
    showLoading(true);
    try {
        await loadTransactions();
        renderTransactionsTable();
        showToast('Transactions refreshed successfully', 'success');
    } catch (error) {
        console.error('Error refreshing transactions:', error);
        showToast('Error refreshing transactions', 'error');
    } finally {
        showLoading(false);
    }
}

function renderTransactionsTable() {
    const tbody = document.getElementById('transactionsTableBody');

    if (allTransactions.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="8" style="text-align: center; padding: 40px;">
                    No transactions available
                </td>
            </tr>
        `;
        return;
    }

    const recent = allTransactions
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
        .slice(0, 50);

    tbody.innerHTML = recent.map(t => {
        const crop = allCrops.find(c => c.id === t.cropId);
        const cropName = crop ? crop.cropName : 'Unknown';

        return `
            <tr>
                <td><strong>${t.id ? t.id.substring(0, 8) : 'N/A'}</strong></td>
                <td>${formatDate(t.createdAt)}</td>
                <td>Farmer ${t.farmerId ? t.farmerId.substring(0, 8) : 'N/A'}</td>
                <td>Buyer ${t.buyerId ? t.buyerId.substring(0, 8) : 'N/A'}</td>
                <td>${cropName}</td>
                <td>${t.quantity || 0} ${t.unit || 'kg'}</td>
                <td><strong>${formatCurrency(t.totalAmount)}</strong></td>
                <td><span class="status-badge" style="background: ${getStatusColor(t.transactionStatus)}20; color: ${getStatusColor(t.transactionStatus)};">
                    ${formatEnum(t.transactionStatus)}
                </span></td>
            </tr>
        `;
    }).join('');
}

function getStatusColor(status) {
    const colors = {
        'PENDING': '#f59e0b',
        'CONFIRMED': '#3b82f6',
        'DELIVERED': '#22c55e',
        'PAID': '#10b981',
        'COMPLETED': '#22c55e',
        'CANCELLED': '#ef4444',
        'DISPUTED': '#ef4444'
    };
    return colors[status] || '#666666';
}

// ==================== EXPORT FUNCTIONS ====================
async function exportTransactionsExcel() {
    try {
        if (allTransactions.length === 0) {
            showToast('No transactions to export', 'warning');
            return;
        }

        const exportData = allTransactions.map((t, index) => {
            const crop = allCrops.find(c => c.id === t.cropId);
            return {
                '#': index + 1,
                'Transaction ID': t.id || 'N/A',
                'Date': formatDate(t.createdAt),
                'Farmer ID': t.farmerId || 'N/A',
                'Buyer ID': t.buyerId || 'N/A',
                'Crop': crop ? crop.cropName : 'Unknown',
                'Quantity': t.quantity || 0,
                'Unit': t.unit || 'kg',
                'Price per Unit': t.pricePerUnit || 0,
                'Total Amount': t.totalAmount || 0,
                'Status': formatEnum(t.transactionStatus),
                'Payment Method': formatEnum(t.paymentMethod),
                'Delivery Location': t.deliveryLocation || 'N/A'
            };
        });

        const ws = XLSX.utils.json_to_sheet(exportData);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Transactions');
        XLSX.writeFile(wb, `transactions_export_${Date.now()}.xlsx`);

        showToast('Excel file exported successfully', 'success');
    } catch (error) {
        console.error('Error exporting to Excel:', error);
        showToast('Error exporting to Excel', 'error');
    }
}








// ==================== HELPER FUNCTION FOR LOGO ====================
async function loadLogoAsBase64() {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function() {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const base64 = canvas.toDataURL('image/jpeg');
                resolve(base64);
            } catch (error) {
                console.error('Error converting logo:', error);
                resolve(null);
            }
        };
        img.onerror = () => resolve(null);
        img.src = 'images/logo.jpeg';
    });
}

// ==================== MAIN PDF GENERATION FUNCTION ====================
async function generatePDFReport() {
    try {
        showLoading(true);

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        const reportType = document.getElementById('reportType').value;
        const reportPeriod = document.getElementById('reportPeriod').value;

        // ==================== COLORS & STYLING ====================
        const primaryGreen = [34, 197, 94];
        const darkGreen = [22, 163, 74];
        const lightGreen = [220, 252, 231];
        const textDark = [51, 51, 51];
        const textGray = [102, 102, 102];
        const borderColor = [224, 224, 224];

        // Load logo
        const logoBase64 = await loadLogoAsBase64();

        // ==================== HEADER WITH LOGO ====================
        function addHeader(doc) {
            doc.setFillColor(...primaryGreen);
            doc.rect(0, 0, 210, 40, 'F');

            // Add logo
            if (logoBase64) {
                try {
                    doc.addImage(logoBase64, 'JPEG', 15, 10, 20, 20);
                } catch (error) {
                    console.error('Error adding logo:', error);
                    // Fallback
                    doc.setFillColor(255, 255, 255);
                    doc.roundedRect(15, 10, 20, 20, 3, 3, 'F');
                    doc.setTextColor(...darkGreen);
                    doc.setFontSize(16);
                    doc.setFont('helvetica', 'bold');
                    doc.text('AG', 25, 23, { align: 'center' });
                }
            }

            doc.setTextColor(255, 255, 255);
            doc.setFontSize(22);
            doc.setFont('helvetica', 'bold');
            doc.text('AgriGuard AI', 40, 18);

            doc.setFontSize(11);
            doc.setFont('helvetica', 'normal');
            doc.text('Smart Agriculture Management System', 40, 25);

            doc.setFontSize(13);
            doc.setFont('helvetica', 'bold');
            const reportTitles = {
                comprehensive: 'Comprehensive Analysis Report',
                transactions: 'Transaction Report',
                crops: 'Crop Production Report',
                market: 'Market Analysis Report',
                weather: 'Weather Impact Report',
                soil: 'Soil Health Report',
                predictions: 'AI Predictions Report'
            };
            doc.text(reportTitles[reportType] || 'All Users Report', 40, 33);
        }

        // ==================== FOOTER ====================
        function addFooter(doc, pageNumber, totalPages) {
            const pageHeight = doc.internal.pageSize.height;
            doc.setDrawColor(...borderColor);
            doc.setLineWidth(0.5);
            doc.line(15, pageHeight - 15, 195, pageHeight - 15);

            doc.setFontSize(8);
            doc.setTextColor(...textGray);
            doc.setFont('helvetica', 'normal');
            doc.text(
                `AgriGuard AI - Generated on ${new Date().toLocaleDateString()}`,
                105,
                pageHeight - 10,
                { align: 'center' }
            );

            doc.text(
                `Page ${pageNumber} of ${totalPages}`,
                195,
                pageHeight - 10,
                { align: 'right' }
            );
        }

        // Add first page header
        addHeader(doc);

        // ==================== GENERATE REPORT BY TYPE ====================
        switch (reportType) {
            case 'transactions':
                await generateTransactionReport(doc, reportPeriod, primaryGreen, lightGreen, textDark, textGray, borderColor);
                break;
            case 'crops':
                await generateCropProductionReport(doc, reportPeriod, primaryGreen, lightGreen, textDark, textGray, borderColor);
                break;
            case 'market':
                await generateMarketAnalysisReport(doc, reportPeriod, primaryGreen, lightGreen, textDark, textGray, borderColor);
                break;
            case 'weather':
                await generateWeatherImpactReport(doc, reportPeriod, primaryGreen, lightGreen, textDark, textGray, borderColor);
                break;
            case 'soil':
                await generateSoilHealthReport(doc, reportPeriod, primaryGreen, lightGreen, textDark, textGray, borderColor);
                break;
            case 'predictions':
                await generatePredictionsReport(doc, reportPeriod, primaryGreen, lightGreen, textDark, textGray, borderColor);
                break;
            default:
                await generateComprehensiveReport(doc, reportPeriod, primaryGreen, darkGreen, lightGreen, textDark, textGray, borderColor, logoBase64);
        }

        // Add footers to all pages
        const totalPages = doc.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
            doc.setPage(i);
            addFooter(doc, i, totalPages);
        }

        // ==================== SAVE PDF ====================
        const filename = `AgriGuard_${reportType}_Report_${Date.now()}.pdf`;
        doc.save(filename);

        showToast('PDF report generated successfully! â', 'success');
    } catch (error) {
        console.error('Error generating PDF:', error);
        showToast('Error generating PDF report â', 'error');
    } finally {
        showLoading(false);
    }
}

// ==================== TRANSACTION REPORT ====================
async function generateTransactionReport(doc, period, primaryGreen, lightGreen, textDark, textGray, borderColor) {
    let yPos = 50;

    // Info box
    doc.setFillColor(...lightGreen);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'F');
    doc.setDrawColor(...primaryGreen);
    doc.setLineWidth(0.5);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'S');

    doc.setTextColor(...textDark);
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');

    doc.text('Report Generated:', 20, yPos + 7);
    doc.text('Total Records:', 20, yPos + 14);
    doc.text('Generated By:', 20, yPos + 21);

    doc.setFont('helvetica', 'normal');
    const today = new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });
    doc.text(today, 60, yPos + 7);

    doc.setTextColor(...primaryGreen);
    doc.setFont('helvetica', 'bold');
    doc.text(allTransactions.length.toString(), 60, yPos + 14);

    doc.setTextColor(...textDark);
    doc.setFont('helvetica', 'normal');
    doc.text('AgriGuard AI System', 60, yPos + 21);

    doc.setFont('helvetica', 'bold');
    doc.text('Period:', 120, yPos + 7);
    doc.text('Total Revenue:', 120, yPos + 14);

    doc.setFont('helvetica', 'normal');
    const periodText = period === '7' ? 'Last 7 Days' :
                      period === '30' ? 'Last 30 Days' :
                      period === '90' ? 'Last 90 Days' :
                      period === '365' ? 'Last Year' : 'Custom';
    doc.text(periodText, 145, yPos + 7);

    const totalRevenue = allTransactions.reduce((sum, t) => sum + (parseFloat(t.totalAmount) || 0), 0);
    doc.text(formatCurrency(totalRevenue), 145, yPos + 14);

    yPos += 38;

    // Transaction Details Section
    doc.setFillColor(...primaryGreen);
    doc.rect(15, yPos, 180, 10, 'F');

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Transaction Details', 20, yPos + 7);

    yPos += 15;

    // Prepare transaction data
    const transactionData = allTransactions.slice(0, 100).map((t, index) => {
        const crop = allCrops.find(c => c.id === t.cropId);
        return [
            (index + 1).toString(),
            t.id ? t.id.substring(0, 10) : 'N/A',
            formatDate(t.createdAt),
            crop ? crop.cropName : 'Unknown',
            `${t.quantity || 0} ${t.unit || 'kg'}`,
            formatCurrency(t.totalAmount),
            formatEnum(t.transactionStatus)
        ];
    });

    doc.autoTable({
        startY: yPos,
        head: [['#', 'Transaction ID', 'Date', 'Crop', 'Quantity', 'Amount', 'Status']],
        body: transactionData,
        theme: 'striped',
        headStyles: {
            fillColor: primaryGreen,
            textColor: [255, 255, 255],
            fontSize: 8,
            fontStyle: 'bold',
            halign: 'left',
            cellPadding: 3
        },
        bodyStyles: {
            fontSize: 7,
            textColor: textDark,
            cellPadding: 2
        },
        alternateRowStyles: {
            fillColor: [249, 250, 251]
        },
        columnStyles: {
            0: { cellWidth: 10, halign: 'center' },
            1: { cellWidth: 28 },
            2: { cellWidth: 26 },
            3: { cellWidth: 28 },
            4: { cellWidth: 24 },
            5: { cellWidth: 28 },
            6: { cellWidth: 24, halign: 'center' }
        },
        margin: { left: 15, right: 15 }
    });

    // Add statistics page
    doc.addPage();
    addStatisticsPage(doc, 'transactions', primaryGreen, textDark, textGray, borderColor);
}

// ==================== CROP PRODUCTION REPORT ====================
async function generateCropProductionReport(doc, period, primaryGreen, lightGreen, textDark, textGray, borderColor) {
    let yPos = 50;

    // Info box
    doc.setFillColor(...lightGreen);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'F');
    doc.setDrawColor(...primaryGreen);
    doc.setLineWidth(0.5);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'S');

    doc.setTextColor(...textDark);
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');

    doc.text('Report Generated:', 20, yPos + 7);
    doc.text('Total Productions:', 20, yPos + 14);
    doc.text('Generated By:', 20, yPos + 21);

    doc.setFont('helvetica', 'normal');
    doc.text(new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    }), 60, yPos + 7);

    doc.setTextColor(...primaryGreen);
    doc.setFont('helvetica', 'bold');
    doc.text(allCropProductions.length.toString(), 60, yPos + 14);

    doc.setTextColor(...textDark);
    doc.setFont('helvetica', 'normal');
    doc.text('AgriGuard AI System', 60, yPos + 21);

    doc.setFont('helvetica', 'bold');
    doc.text('Period:', 120, yPos + 7);
    doc.text('Total Yield:', 120, yPos + 14);

    doc.setFont('helvetica', 'normal');
    const periodText = period === '7' ? 'Last 7 Days' :
                      period === '30' ? 'Last 30 Days' :
                      period === '90' ? 'Last 90 Days' :
                      period === '365' ? 'Last Year' : 'All Time';
    doc.text(periodText, 145, yPos + 7);

    const totalYield = allCropProductions.reduce((sum, cp) =>
        sum + (parseFloat(cp.actualYield) || parseFloat(cp.expectedYield) || 0), 0
    );
    doc.text(`${totalYield.toFixed(1)} tons`, 145, yPos + 14);

    yPos += 38;

    // Crop Production Details
    doc.setFillColor(...primaryGreen);
    doc.rect(15, yPos, 180, 10, 'F');

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Crop Production Details', 20, yPos + 7);

    yPos += 15;

    const cropData = allCropProductions.slice(0, 100).map((cp, index) => {
        const crop = allCrops.find(c => c.id === cp.cropId);
        return [
            (index + 1).toString(),
            crop ? crop.cropName : 'Unknown',
            cp.season || 'N/A',
            `${cp.areaInHectares || 0} ha`,
            `${parseFloat(cp.actualYield || cp.expectedYield || 0).toFixed(1)} t/ha`,
            formatEnum(cp.productionStatus),
            formatDate(cp.plantingDate)
        ];
    });

    doc.autoTable({
        startY: yPos,
        head: [['#', 'Crop', 'Season', 'Area', 'Yield', 'Status', 'Planting Date']],
        body: cropData,
        theme: 'striped',
        headStyles: {
            fillColor: primaryGreen,
            textColor: [255, 255, 255],
            fontSize: 8,
            fontStyle: 'bold',
            halign: 'left',
            cellPadding: 3
        },
        bodyStyles: {
            fontSize: 7,
            textColor: textDark,
            cellPadding: 2
        },
        alternateRowStyles: {
            fillColor: [249, 250, 251]
        },
        columnStyles: {
            0: { cellWidth: 10, halign: 'center' },
            1: { cellWidth: 33 },
            2: { cellWidth: 24 },
            3: { cellWidth: 19 },
            4: { cellWidth: 24 },
            5: { cellWidth: 28, halign: 'center' },
            6: { cellWidth: 30 }
        },
        margin: { left: 15, right: 15 }
    });

    doc.addPage();
    addStatisticsPage(doc, 'crops', primaryGreen, textDark, textGray, borderColor);
}

// ==================== MARKET ANALYSIS REPORT ====================
async function generateMarketAnalysisReport(doc, period, primaryGreen, lightGreen, textDark, textGray, borderColor) {
    let yPos = 50;

    // Info box
    doc.setFillColor(...lightGreen);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'F');
    doc.setDrawColor(...primaryGreen);
    doc.setLineWidth(0.5);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'S');

    doc.setTextColor(...textDark);
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');

    doc.text('Report Generated:', 20, yPos + 7);
    doc.text('Total Price Records:', 20, yPos + 14);
    doc.text('Generated By:', 20, yPos + 21);

    doc.setFont('helvetica', 'normal');
    doc.text(new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    }), 60, yPos + 7);

    doc.setTextColor(...primaryGreen);
    doc.setFont('helvetica', 'bold');
    doc.text(allMarketPrices.length.toString(), 60, yPos + 14);

    doc.setTextColor(...textDark);
    doc.setFont('helvetica', 'normal');
    doc.text('AgriGuard AI System', 60, yPos + 21);

    doc.setFont('helvetica', 'bold');
    doc.text('Period:', 120, yPos + 7);
    doc.text('Avg Price:', 120, yPos + 14);

    doc.setFont('helvetica', 'normal');
    const periodText = period === '7' ? 'Last 7 Days' :
                      period === '30' ? 'Last 30 Days' :
                      period === '90' ? 'Last 90 Days' :
                      period === '365' ? 'Last Year' : 'All Time';
    doc.text(periodText, 145, yPos + 7);

    const avgPrice = allMarketPrices.length > 0
        ? allMarketPrices.reduce((sum, mp) => sum + (parseFloat(mp.pricePerKg) || 0), 0) / allMarketPrices.length
        : 0;
    doc.text(`${formatCurrency(avgPrice)}/kg`, 145, yPos + 14);

    yPos += 38;

    // Market Price Details
    doc.setFillColor(...primaryGreen);
    doc.rect(15, yPos, 180, 10, 'F');

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Market Price Details', 20, yPos + 7);

    yPos += 15;

    const marketData = allMarketPrices.slice(0, 100).map((mp, index) => {
        const crop = allCrops.find(c => c.id === mp.cropId);
        return [
            (index + 1).toString(),
            crop ? crop.cropName : 'Unknown',
            formatCurrency(mp.pricePerKg) + '/kg',
            mp.location || 'N/A',
            formatEnum(mp.demandLevel),
            formatEnum(mp.supplyLevel),
            formatDate(mp.priceDate)
        ];
    });

    doc.autoTable({
        startY: yPos,
        head: [['#', 'Crop', 'Price', 'Location', 'Demand', 'Supply', 'Date']],
        body: marketData,
        theme: 'striped',
        headStyles: {
            fillColor: primaryGreen,
            textColor: [255, 255, 255],
            fontSize: 8,
            fontStyle: 'bold',
            halign: 'left',
            cellPadding: 3
        },
        bodyStyles: {
            fontSize: 7,
            textColor: textDark,
            cellPadding: 2
        },
        alternateRowStyles: {
            fillColor: [249, 250, 251]
        },
        columnStyles: {
            0: { cellWidth: 10, halign: 'center' },
            1: { cellWidth: 32 },
            2: { cellWidth: 26 },
            3: { cellWidth: 28 },
            4: { cellWidth: 22, halign: 'center' },
            5: { cellWidth: 22, halign: 'center' },
            6: { cellWidth: 28 }
        },
        margin: { left: 15, right: 15 }
    });

    doc.addPage();
    addStatisticsPage(doc, 'market', primaryGreen, textDark, textGray, borderColor);
}

// ==================== WEATHER IMPACT REPORT ====================
async function generateWeatherImpactReport(doc, period, primaryGreen, lightGreen, textDark, textGray, borderColor) {
    let yPos = 50;

    // Info box
    doc.setFillColor(...lightGreen);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'F');
    doc.setDrawColor(...primaryGreen);
    doc.setLineWidth(0.5);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'S');

    doc.setTextColor(...textDark);
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');

    doc.text('Report Generated:', 20, yPos + 7);
    doc.text('Total Weather Records:', 20, yPos + 14);
    doc.text('Generated By:', 20, yPos + 21);

    doc.setFont('helvetica', 'normal');
    doc.text(new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    }), 60, yPos + 7);

    doc.setTextColor(...primaryGreen);
    doc.setFont('helvetica', 'bold');
    doc.text(allWeatherData.length.toString(), 60, yPos + 14);

    doc.setTextColor(...textDark);
    doc.setFont('helvetica', 'normal');
    doc.text('AgriGuard AI System', 60, yPos + 21);

    doc.setFont('helvetica', 'bold');
    doc.text('Period:', 120, yPos + 7);
    doc.text('Avg Temperature:', 120, yPos + 14);

    doc.setFont('helvetica', 'normal');
    const periodText = period === '7' ? 'Last 7 Days' :
                      period === '30' ? 'Last 30 Days' :
                      period === '90' ? 'Last 90 Days' :
                      period === '365' ? 'Last Year' : 'All Time';
    doc.text(periodText, 145, yPos + 7);

    const avgTemp = allWeatherData.length > 0
        ? allWeatherData.reduce((sum, w) => sum + (parseFloat(w.temperature) || 0), 0) / allWeatherData.length
        : 0;
    doc.text(`${avgTemp.toFixed(1)}Â°C`, 145, yPos + 14);

    yPos += 38;

    // Weather Data Details
    doc.setFillColor(...primaryGreen);
    doc.rect(15, yPos, 180, 10, 'F');

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Weather Data Details', 20, yPos + 7);

    yPos += 15;

    const weatherData = allWeatherData.slice(0, 100).map((w, index) => [
        (index + 1).toString(),
        formatDate(w.measurementDate || w.recordDate),
        `${parseFloat(w.temperature || 0).toFixed(1)}Â°C`,
        `${parseFloat(w.rainfall || 0).toFixed(1)} mm`,
        `${parseFloat(w.humidity || 0).toFixed(0)}%`,
        `${parseFloat(w.windSpeed || 0).toFixed(1)} m/s`,
        formatEnum(w.weatherCondition)
    ]);

    doc.autoTable({
        startY: yPos,
        head: [['#', 'Date', 'Temp', 'Rainfall', 'Humidity', 'Wind', 'Condition']],
        body: weatherData,
        theme: 'striped',
        headStyles: {
            fillColor: primaryGreen,
            textColor: [255, 255, 255],
            fontSize: 8,
            fontStyle: 'bold',
            halign: 'left',
            cellPadding: 3
        },
        bodyStyles: {
            fontSize: 7,
            textColor: textDark,
            cellPadding: 2
        },
        alternateRowStyles: {
            fillColor: [249, 250, 251]
        },
        columnStyles: {
            0: { cellWidth: 10, halign: 'center' },
            1: { cellWidth: 26 },
            2: { cellWidth: 21 },
            3: { cellWidth: 24 },
            4: { cellWidth: 22 },
            5: { cellWidth: 21 },
            6: { cellWidth: 28, halign: 'center' }
        },
        margin: { left: 15, right: 15 }
    });

    doc.addPage();
    addStatisticsPage(doc, 'weather', primaryGreen, textDark, textGray, borderColor);
}

// ==================== SOIL HEALTH REPORT ====================
async function generateSoilHealthReport(doc, period, primaryGreen, lightGreen, textDark, textGray, borderColor) {
    let yPos = 50;

    // Info box
    doc.setFillColor(...lightGreen);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'F');
    doc.setDrawColor(...primaryGreen);
    doc.setLineWidth(0.5);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'S');

    doc.setTextColor(...textDark);
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');

    doc.text('Report Generated:', 20, yPos + 7);
    doc.text('Total Soil Samples:', 20, yPos + 14);
    doc.text('Generated By:', 20, yPos + 21);

    doc.setFont('helvetica', 'normal');
    doc.text(new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    }), 60, yPos + 7);

    doc.setTextColor(...primaryGreen);
    doc.setFont('helvetica', 'bold');
    doc.text(allSoilData.length.toString(), 60, yPos + 14);

    doc.setTextColor(...textDark);
    doc.setFont('helvetica', 'normal');
    doc.text('AgriGuard AI System', 60, yPos + 21);

    doc.setFont('helvetica', 'bold');
    doc.text('Period:', 120, yPos + 7);
    doc.text('Avg Soil Quality:', 120, yPos + 14);

    doc.setFont('helvetica', 'normal');
    const periodText = period === '7' ? 'Last 7 Days' :
                      period === '30' ? 'Last 30 Days' :
                      period === '90' ? 'Last 90 Days' :
                      period === '365' ? 'Last Year' : 'All Time';
    doc.text(periodText, 145, yPos + 7);

    const avgQuality = calculateAverageSoilQuality();
    doc.text(`${avgQuality.toFixed(0)}%`, 145, yPos + 14);

    yPos += 38;

    // Soil Data Details
    doc.setFillColor(...primaryGreen);
    doc.rect(15, yPos, 180, 10, 'F');

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('Soil Analysis Details', 20, yPos + 7);

    yPos += 15;

    const soilData = allSoilData.slice(0, 100).map((s, index) => [
        (index + 1).toString(),
        formatDate(s.measurementDate || s.createdAt),
        `${parseFloat(s.phLevel || 0).toFixed(1)}`,
        `${parseFloat(s.nitrogen || 0).toFixed(1)} ppm`,
        `${parseFloat(s.phosphorus || 0).toFixed(1)} ppm`,
        `${parseFloat(s.potassium || 0).toFixed(1)} ppm`,
        formatEnum(s.soilTexture)
    ]);

    doc.autoTable({
        startY: yPos,
        head: [['#', 'Date', 'pH', 'N', 'P', 'K', 'Texture']],
        body: soilData,
        theme: 'striped',
        headStyles: {
            fillColor: primaryGreen,
            textColor: [255, 255, 255],
            fontSize: 8,
            fontStyle: 'bold',
            halign: 'left',
            cellPadding: 3
        },
        bodyStyles: {
            fontSize: 7,
            textColor: textDark,
            cellPadding: 2
        },
        alternateRowStyles: {
            fillColor: [249, 250, 251]
        },
        columnStyles: {
            0: { cellWidth: 10, halign: 'center' },
            1: { cellWidth: 26 },
            2: { cellWidth: 19 },
            3: { cellWidth: 26 },
            4: { cellWidth: 26 },
            5: { cellWidth: 26 },
            6: { cellWidth: 28, halign: 'center' }
        },
        margin: { left: 15, right: 15 }
    });

    doc.addPage();
    addStatisticsPage(doc, 'soil', primaryGreen, textDark, textGray, borderColor);
}

// ==================== PREDICTIONS REPORT ====================
async function generatePredictionsReport(doc, period, primaryGreen, lightGreen, textDark, textGray, borderColor) {
    let yPos = 50;

    // Info box
    doc.setFillColor(...lightGreen);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'F');
    doc.setDrawColor(...primaryGreen);
    doc.setLineWidth(0.5);
    doc.roundedRect(15, yPos, 180, 28, 2, 2, 'S');

    doc.setTextColor(...textDark);
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');

    doc.text('Report Generated:', 20, yPos + 7);
    doc.text('Analysis Period:', 20, yPos + 14);
    doc.text('Generated By:', 20, yPos + 21);

    doc.setFont('helvetica', 'normal');
    doc.text(new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    }), 60, yPos + 7);

    doc.setTextColor(...primaryGreen);
    doc.setFont('helvetica', 'bold');
    doc.text('AI-Powered Predictions', 60, yPos + 14);

    doc.setTextColor(...textDark);
    doc.setFont('helvetica', 'normal');
    doc.text('AgriGuard AI System', 60, yPos + 21);

    yPos += 38;

    // AI Predictions Section
    doc.setFillColor(...primaryGreen);
    doc.rect(15, yPos, 180, 10, 'F');

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text('AI Predictions & Insights', 20, yPos + 7);

    yPos += 20;

    // Add predictions as formatted text boxes
    const predictions = [
        {
            title: 'Crop Yield Prediction',
            content: `Predicted total yield: ${(allCropProductions.length * 2.5).toFixed(1)} tons
Confidence level: 85%
Expected harvest period: Next 30-60 days`
        },
        {
            title: 'Market Price Forecast',
            content: `Average price trend: Upward (+5-8%)
Best selling period: Next 2-3 weeks
High demand crops: Top 3 categories`
        },
        {
            title: 'Weather Impact Analysis',
            content: `Weather risk level: Low to Medium
Irrigation needs: Moderate
Recommended actions: Monitor closely`
        },
        {
            title: 'Soil Health Forecast',
            content: `Overall soil quality: ${calculateAverageSoilQuality().toFixed(0)}%
Nutrient status: Good
Action required: Routine maintenance`
        }
    ];

    predictions.forEach((pred, index) => {
        // Prediction box
        doc.setDrawColor(...borderColor);
        doc.setLineWidth(0.3);
        doc.roundedRect(15, yPos, 180, 30, 2, 2, 'S');

        // Left accent
        doc.setFillColor(...primaryGreen);
        doc.rect(15, yPos, 3, 30, 'F');

        // Title
        doc.setTextColor(...textDark);
        doc.setFontSize(10);
        doc.setFont('helvetica', 'bold');
        doc.text(pred.title, 23, yPos + 7);

        // Content
        doc.setTextColor(...textGray);
        doc.setFontSize(8);
        doc.setFont('helvetica', 'normal');
        const lines = doc.splitTextToSize(pred.content, 160);
        doc.text(lines, 23, yPos + 14);

        yPos += 35;
    });

    doc.addPage();
    addStatisticsPage(doc, 'predictions', primaryGreen, textDark, textGray, borderColor);
}

// ==================== COMPREHENSIVE REPORT ====================
async function generateComprehensiveReport(doc, period, primaryGreen, darkGreen, lightGreen, textDark, textGray, borderColor, logoBase64) {
    // This combines all reports - reuse existing logic
    await generateTransactionReport(doc, period, primaryGreen, lightGreen, textDark, textGray, borderColor);

    doc.addPage();
    addHeaderToPage(doc, logoBase64, 'Comprehensive Analysis Report', primaryGreen, darkGreen);
    await generateCropProductionReport(doc, period, primaryGreen, lightGreen, textDark, textGray, borderColor);
}

// ==================== STATISTICS PAGE ====================
function addStatisticsPage(doc, reportType, primaryGreen, textDark, textGray, borderColor) {
    let yPos = 20;

    // Title
    doc.setFillColor(...primaryGreen);
    doc.rect(0, 0, 210, 30, 'F');

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(18);
    doc.setFont('helvetica', 'bold');
    doc.text('System Statistics', 105, 20, { align: 'center' });

    yPos = 40;

    // Statistics boxes based on report type
    let stats = [];

    switch (reportType) {
        case 'transactions':
            const totalRevenue = allTransactions.reduce((s, t) => s + (parseFloat(t.totalAmount) || 0), 0);
            const avgTransValue = allTransactions.length > 0 ? totalRevenue / allTransactions.length : 0;

            stats = [
                { label: 'Total Transactions', value: allTransactions.length.toString(), color: primaryGreen },
                { label: 'Total Revenue', value: formatCurrency(totalRevenue), color: [59, 130, 246] },
                { label: 'Active Farmers', value: new Set(allTransactions.map(t => t.farmerId).filter(Boolean)).size.toString(), color: [245, 158, 11] },
                { label: 'Active Buyers', value: new Set(allTransactions.map(t => t.buyerId).filter(Boolean)).size.toString(), color: [139, 92, 246] },
                { label: 'Avg Transaction Value', value: formatCurrency(avgTransValue), color: [16, 185, 129] },
                { label: 'Completed Transactions', value: allTransactions.filter(t => t.transactionStatus === 'COMPLETED').length.toString(), color: [34, 197, 94] }
            ];
            break;
        case 'crops':
            const totalYield = allCropProductions.reduce((s, cp) => s + (parseFloat(cp.actualYield || cp.expectedYield) || 0), 0);
            const totalArea = allCropProductions.reduce((s, cp) => s + (parseFloat(cp.areaInHectares) || 0), 0);

            stats = [
                { label: 'Total Productions', value: allCropProductions.length.toString(), color: primaryGreen },
                { label: 'Harvested', value: allCropProductions.filter(cp => cp.productionStatus === 'HARVESTED').length.toString(), color: [34, 197, 94] },
                { label: 'Total Area', value: `${totalArea.toFixed(1)} ha`, color: [245, 158, 11] },
                { label: 'Total Yield', value: `${totalYield.toFixed(1)} tons`, color: [59, 130, 246] },
                { label: 'Active Productions', value: allCropProductions.filter(cp => cp.productionStatus === 'PLANTED' || cp.productionStatus === 'GROWING').length.toString(), color: [16, 185, 129] },
                { label: 'Unique Crops', value: new Set(allCropProductions.map(cp => cp.cropId)).size.toString(), color: [139, 92, 246] }
            ];
            break;
        case 'market':
            const avgMarketPrice = allMarketPrices.length > 0
                ? allMarketPrices.reduce((s, mp) => s + (parseFloat(mp.pricePerKg) || 0), 0) / allMarketPrices.length
                : 0;

            stats = [
                { label: 'Price Records', value: allMarketPrices.length.toString(), color: primaryGreen },
                { label: 'Average Price', value: `${formatCurrency(avgMarketPrice)}/kg`, color: [59, 130, 246] },
                { label: 'Unique Locations', value: new Set(allMarketPrices.map(mp => mp.location)).size.toString(), color: [245, 158, 11] },
                { label: 'High Demand', value: allMarketPrices.filter(mp => mp.demandLevel === 'HIGH' || mp.demandLevel === 'VERY_HIGH').length.toString(), color: [239, 68, 68] },
                { label: 'Low Supply', value: allMarketPrices.filter(mp => mp.supplyLevel === 'LOW').length.toString(), color: [245, 158, 11] },
                { label: 'Tracked Crops', value: new Set(allMarketPrices.map(mp => mp.cropId)).size.toString(), color: [16, 185, 129] }
            ];
            break;
        case 'weather':
            const avgWeatherTemp = allWeatherData.length > 0
                ? allWeatherData.reduce((s, w) => s + (parseFloat(w.temperature) || 0), 0) / allWeatherData.length
                : 0;
            const totalRainfall = allWeatherData.reduce((s, w) => s + (parseFloat(w.rainfall) || 0), 0);
            const avgHumidity = allWeatherData.length > 0
                ? allWeatherData.reduce((s, w) => s + (parseFloat(w.humidity) || 0), 0) / allWeatherData.length
                : 0;
            const avgWindSpeed = allWeatherData.length > 0
                ? allWeatherData.reduce((s, w) => s + (parseFloat(w.windSpeed) || 0), 0) / allWeatherData.length
                : 0;

            stats = [
                { label: 'Weather Records', value: allWeatherData.length.toString(), color: primaryGreen },
                { label: 'Avg Temperature', value: `${avgWeatherTemp.toFixed(1)}Â°C`, color: [239, 68, 68] },
                { label: 'Total Rainfall', value: `${totalRainfall.toFixed(1)} mm`, color: [59, 130, 246] },
                { label: 'Avg Humidity', value: `${avgHumidity.toFixed(0)}%`, color: [6, 182, 212] },
                { label: 'Avg Wind Speed', value: `${avgWindSpeed.toFixed(1)} m/s`, color: [132, 204, 22] },
                { label: 'Optimal Days', value: allWeatherData.filter(w => {
                    const temp = parseFloat(w.temperature) || 0;
                    const hum = parseFloat(w.humidity) || 0;
                    return temp >= 20 && temp <= 30 && hum >= 40 && hum <= 70;
                }).length.toString(), color: [34, 197, 94] }
            ];
            break;
        case 'soil':
            const avgSoilQuality = calculateAverageSoilQuality();
            const avgPH = allSoilData.length > 0
                ? allSoilData.reduce((s, sd) => s + (parseFloat(sd.phLevel) || 0), 0) / allSoilData.length
                : 0;
            const avgNitrogen = allSoilData.length > 0
                ? allSoilData.reduce((s, sd) => s + (parseFloat(sd.nitrogen) || 0), 0) / allSoilData.length
                : 0;
            const avgPhosphorus = allSoilData.length > 0
                ? allSoilData.reduce((s, sd) => s + (parseFloat(sd.phosphorus) || 0), 0) / allSoilData.length
                : 0;
            const avgPotassium = allSoilData.length > 0
                ? allSoilData.reduce((s, sd) => s + (parseFloat(sd.potassium) || 0), 0) / allSoilData.length
                : 0;

            stats = [
                { label: 'Soil Samples', value: allSoilData.length.toString(), color: primaryGreen },
                { label: 'Avg Soil Quality', value: `${avgSoilQuality.toFixed(0)}%`, color: [34, 197, 94] },
                { label: 'Avg pH Level', value: avgPH.toFixed(1), color: [234, 179, 8] },
                { label: 'Avg Nitrogen', value: `${avgNitrogen.toFixed(1)} ppm`, color: [34, 197, 94] },
                { label: 'Avg Phosphorus', value: `${avgPhosphorus.toFixed(1)} ppm`, color: [59, 130, 246] },
                { label: 'Avg Potassium', value: `${avgPotassium.toFixed(1)} ppm`, color: [245, 158, 11] }
            ];
            break;
        default:
            stats = [
                { label: 'Total Transactions', value: allTransactions.length.toString(), color: primaryGreen },
                { label: 'Crop Productions', value: allCropProductions.length.toString(), color: [16, 185, 129] },
                { label: 'Market Records', value: allMarketPrices.length.toString(), color: [239, 68, 68] },
                { label: 'Weather Data', value: allWeatherData.length.toString(), color: [59, 130, 246] },
                { label: 'Soil Samples', value: allSoilData.length.toString(), color: [245, 158, 11] },
                { label: 'System Health', value: '95%', color: [34, 197, 94] }
            ];
    }

    let xPos = 15;
    let statYPos = yPos;

    stats.forEach((stat, index) => {
        if (index > 0 && index % 3 === 0) {
            statYPos += 50;
            xPos = 15;
        }

        // Stat box with improved styling
        doc.setFillColor(249, 250, 251);
        doc.roundedRect(xPos, statYPos, 58, 40, 2, 2, 'F');

        doc.setDrawColor(...stat.color);
        doc.setLineWidth(1);
        doc.roundedRect(xPos, statYPos, 58, 40, 2, 2, 'S');

        // Icon background (larger circle)
        doc.setFillColor(...stat.color);
        doc.circle(xPos + 12, statYPos + 12, 6, 'F');

        // Value - PROFESSIONAL POSITIONING
        doc.setTextColor(...stat.color);
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');

        // Center the value horizontally and position it properly
        const valueText = stat.value;
        const valueWidth = doc.getTextWidth(valueText);
        const valueCenterX = xPos + 29; // Center of the box

        doc.text(valueText, valueCenterX, statYPos + 24, { align: 'center' });

        // Label - positioned below value
        doc.setTextColor(...textGray);
        doc.setFontSize(7);
        doc.setFont('helvetica', 'normal');

        const lines = doc.splitTextToSize(stat.label, 50);
        doc.text(lines, xPos + 29, statYPos + 32, { align: 'center' });

        xPos += 62;
    });

    // Add insights
    yPos = statYPos + 60;

    doc.setFillColor(...primaryGreen);
    doc.rect(15, yPos, 180, 8, 'F');

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.text('Key Insights', 20, yPos + 5.5);

    yPos += 15;

    const insights = getInsightsForReportType(reportType);

    insights.forEach((insight) => {
        doc.setDrawColor(...borderColor);
        doc.setLineWidth(0.3);
        doc.roundedRect(15, yPos, 180, 18, 2, 2, 'S');

        doc.setFillColor(...insight.color);
        doc.rect(15, yPos, 3, 18, 'F');

        doc.setTextColor(...insight.color);
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text(insight.icon, 23, yPos + 7);

        doc.setTextColor(...textDark);
        doc.setFontSize(9);
        doc.setFont('helvetica', 'bold');
        doc.text(insight.title, 30, yPos + 7);

        doc.setTextColor(...textGray);
        doc.setFontSize(8);
        doc.setFont('helvetica', 'normal');
        const textLines = doc.splitTextToSize(insight.text, 160);
        doc.text(textLines, 30, yPos + 13);

        yPos += 22;
    });
}

// Helper function for report-specific insights
function getInsightsForReportType(reportType) {
    const totalRevenue = allTransactions.reduce((s, t) => s + (parseFloat(t.totalAmount) || 0), 0);
    const totalYield = allCropProductions.reduce((s, cp) => s + (parseFloat(cp.actualYield || cp.expectedYield) || 0), 0);
    const avgYield = allCropProductions.length > 0 ? totalYield / allCropProductions.length : 0;

    switch (reportType) {
        case 'transactions':
            return [
                {
                    title: 'Market Activity',
                    text: `Strong transaction volume with ${allTransactions.length} total transactions recorded.`,
                    icon: 'â',
                    color: [34, 197, 94]
                },
                {
                    title: 'Revenue Performance',
                    text: `Total revenue of ${formatCurrency(totalRevenue)} generated.`,
                    icon: 'â',
                    color: [59, 130, 246]
                }
            ];
        case 'crops':
            return [
                {
                    title: 'Production Status',
                    text: `${allCropProductions.filter(cp => cp.productionStatus === 'HARVESTED').length} productions harvested successfully.`,
                    icon: 'â',
                    color: [34, 197, 94]
                },
                {
                    title: 'Yield Performance',
                    text: `Average yield of ${avgYield.toFixed(2)} tons/ha achieved.`,
                    icon: 'â',
                    color: [245, 158, 11]
                }
            ];
        case 'market':
            return [
                {
                    title: 'Price Trends',
                    text: `Market showing ${allMarketPrices.filter(mp => mp.demandLevel === 'HIGH').length} high-demand price points.`,
                    icon: 'â',
                    color: [239, 68, 68]
                },
                {
                    title: 'Market Coverage',
                    text: `Tracking ${new Set(allMarketPrices.map(mp => mp.location)).size} unique locations across the region.`,
                    icon: 'â',
                    color: [59, 130, 246]
                }
            ];
        case 'weather':
            const avgTemp = allWeatherData.length > 0
                ? allWeatherData.reduce((s, w) => s + (parseFloat(w.temperature) || 0), 0) / allWeatherData.length
                : 0;
            return [
                {
                    title: 'Weather Patterns',
                    text: `Favorable conditions detected in ${allWeatherData.filter(w => {
                        const temp = parseFloat(w.temperature) || 0;
                        return temp >= 20 && temp <= 30;
                    }).length} recorded days.`,
                    icon: 'â',
                    color: [34, 197, 94]
                },
                {
                    title: 'Climate Impact',
                    text: `Average temperature of ${avgTemp.toFixed(1)}Â°C within optimal range.`,
                    icon: 'â',
                    color: [59, 130, 246]
                }
            ];
        case 'soil':
            const avgQuality = calculateAverageSoilQuality();
            return [
                {
                    title: 'Soil Health',
                    text: `Overall soil quality at ${avgQuality.toFixed(0)}% - ${avgQuality > 70 ? 'Good' : 'Needs Improvement'} condition.`,
                    icon: 'â',
                    color: avgQuality > 70 ? [34, 197, 94] : [245, 158, 11]
                },
                {
                    title: 'Nutrient Status',
                    text: `NPK levels averaging within acceptable ranges for most samples.`,
                    icon: 'â',
                    color: [34, 197, 94]
                }
            ];
        default:
            return [
                {
                    title: 'System Overview',
                    text: `Comprehensive analysis covering all agricultural data points.`,
                    icon: 'â',
                    color: [34, 197, 94]
                },
                {
                    title: 'Data Quality',
                    text: `High-quality data from multiple sources ensuring accurate insights.`,
                    icon: 'â',
                    color: [59, 130, 246]
                }
            ];
    }
}

// Helper to add header to new pages
function addHeaderToPage(doc, logoBase64, title, primaryGreen, darkGreen) {
    doc.setFillColor(...primaryGreen);
    doc.rect(0, 0, 210, 40, 'F');

    if (logoBase64) {
        try {
            doc.addImage(logoBase64, 'JPEG', 15, 10, 20, 20);
        } catch (error) {
            doc.setFillColor(255, 255, 255);
            doc.roundedRect(15, 10, 20, 20, 3, 3, 'F');
            doc.setTextColor(...darkGreen);
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text('AG', 25, 23, { align: 'center' });
        }
    }

    doc.setTextColor(255, 255, 255);
    doc.setFontSize(22);
    doc.setFont('helvetica', 'bold');
    doc.text('AgriGuard AI', 40, 18);

    doc.setFontSize(11);
    doc.setFont('helvetica', 'normal');
    doc.text('Smart Agriculture Management System', 40, 25);

    doc.setFontSize(13);
    doc.setFont('helvetica', 'bold');
    doc.text(title, 40, 33);
}






// ==================== EXCEL REPORT GENERATION ====================

async function generateExcelReport() {
    try {
        showLoading(true);

        const reportType = document.getElementById('reportType').value;
        const reportPeriod = document.getElementById('reportPeriod').value;

        switch (reportType) {
            case 'comprehensive':
                await exportComprehensiveExcel();
                break;
            case 'transactions':
                await exportTransactionsExcel();
                break;
            case 'crops':
                await exportCropsExcel();
                break;
            case 'market':
                await exportMarketExcel();
                break;
            case 'weather':
                await exportWeatherExcel();
                break;
            case 'soil':
                await exportSoilExcel();
                break;
            case 'predictions':
                await exportPredictionsExcel();
                break;
            default:
                await exportComprehensiveExcel();
        }

        showToast('Excel report generated successfully! â', 'success');
    } catch (error) {
        console.error('Error generating Excel report:', error);
        showToast('Error generating Excel report â', 'error');
    } finally {
        showLoading(false);
    }
}

// ==================== COMPREHENSIVE EXCEL EXPORT ====================
async function exportComprehensiveExcel() {
    const wb = XLSX.utils.book_new();

    // Statistics Sheet
    const totalRevenue = allTransactions.reduce((sum, t) => sum + (parseFloat(t.totalAmount) || 0), 0);
    const totalYield = allCropProductions.reduce((sum, cp) => sum + (parseFloat(cp.actualYield || cp.expectedYield) || 0), 0);

    const statsData = [
        { 'Metric': 'Total Transactions', 'Value': allTransactions.length },
        { 'Metric': 'Total Revenue', 'Value': `RWF ${totalRevenue.toLocaleString()}` },
        { 'Metric': 'Active Farmers', 'Value': new Set(allTransactions.map(t => t.farmerId).filter(Boolean)).size },
        { 'Metric': 'Active Buyers', 'Value': new Set(allTransactions.map(t => t.buyerId).filter(Boolean)).size },
        { 'Metric': 'Crop Productions', 'Value': allCropProductions.length },
        { 'Metric': 'Total Yield', 'Value': `${totalYield.toFixed(1)} tons` },
        { 'Metric': 'Market Price Records', 'Value': allMarketPrices.length },
        { 'Metric': 'Weather Records', 'Value': allWeatherData.length },
        { 'Metric': 'Soil Samples', 'Value': allSoilData.length },
        { 'Metric': 'System Health', 'Value': '95%' }
    ];

    const ws1 = XLSX.utils.json_to_sheet(statsData);
    ws1['!cols'] = [{ wch: 25 }, { wch: 20 }];
    XLSX.utils.book_append_sheet(wb, ws1, 'Statistics');

    // Transactions Sheet
    const transData = allTransactions.slice(0, 1000).map((t, i) => {
        const crop = allCrops.find(c => c.id === t.cropId);
        return {
            '#': i + 1,
            'Transaction ID': t.id || 'N/A',
            'Date': formatDate(t.createdAt),
            'Crop': crop ? crop.cropName : 'Unknown',
            'Quantity': `${t.quantity || 0} ${t.unit || 'kg'}`,
            'Amount (RWF)': parseFloat(t.totalAmount) || 0,
            'Status': formatEnum(t.transactionStatus)
        };
    });

    if (transData.length > 0) {
        const ws2 = XLSX.utils.json_to_sheet(transData);
        ws2['!cols'] = [{ wch: 5 }, { wch: 15 }, { wch: 12 }, { wch: 15 }, { wch: 12 }, { wch: 15 }, { wch: 12 }];
        XLSX.utils.book_append_sheet(wb, ws2, 'Transactions');
    }

    // Crop Productions Sheet
    const cropData = allCropProductions.slice(0, 1000).map((cp, i) => {
        const crop = allCrops.find(c => c.id === cp.cropId);
        return {
            '#': i + 1,
            'Crop': crop ? crop.cropName : 'Unknown',
            'Season': cp.season || 'N/A',
            'Area (ha)': parseFloat(cp.areaInHectares) || 0,
            'Yield (t/ha)': parseFloat(cp.actualYield || cp.expectedYield) || 0,
            'Status': formatEnum(cp.productionStatus),
            'Planting Date': formatDate(cp.plantingDate)
        };
    });

    if (cropData.length > 0) {
        const ws3 = XLSX.utils.json_to_sheet(cropData);
        ws3['!cols'] = [{ wch: 5 }, { wch: 15 }, { wch: 10 }, { wch: 10 }, { wch: 12 }, { wch: 12 }, { wch: 12 }];
        XLSX.utils.book_append_sheet(wb, ws3, 'Crop Productions');
    }

    // Market Prices Sheet
    const marketData = allMarketPrices.slice(0, 1000).map((mp, i) => {
        const crop = allCrops.find(c => c.id === mp.cropId);
        return {
            '#': i + 1,
            'Crop': crop ? crop.cropName : 'Unknown',
            'Price (RWF/kg)': parseFloat(mp.pricePerKg) || 0,
            'Location': mp.location || 'N/A',
            'Demand': formatEnum(mp.demandLevel),
            'Supply': formatEnum(mp.supplyLevel),
            'Date': formatDate(mp.priceDate)
        };
    });

    if (marketData.length > 0) {
        const ws4 = XLSX.utils.json_to_sheet(marketData);
        ws4['!cols'] = [{ wch: 5 }, { wch: 15 }, { wch: 12 }, { wch: 15 }, { wch: 10 }, { wch: 10 }, { wch: 12 }];
        XLSX.utils.book_append_sheet(wb, ws4, 'Market Prices');
    }

    XLSX.writeFile(wb, `AgriGuard_Comprehensive_Report_${Date.now()}.xlsx`);
}

// ==================== TRANSACTIONS EXCEL EXPORT ====================
async function exportTransactionsExcel() {
    const wb = XLSX.utils.book_new();

    const totalRevenue = allTransactions.reduce((sum, t) => sum + (parseFloat(t.totalAmount) || 0), 0);
    const avgTransValue = allTransactions.length > 0 ? totalRevenue / allTransactions.length : 0;

    // Statistics Sheet
    const statsData = [
        { 'Metric': 'Total Transactions', 'Value': allTransactions.length },
        { 'Metric': 'Total Revenue', 'Value': `RWF ${totalRevenue.toLocaleString()}` },
        { 'Metric': 'Average Transaction Value', 'Value': `RWF ${avgTransValue.toLocaleString()}` },
        { 'Metric': 'Active Farmers', 'Value': new Set(allTransactions.map(t => t.farmerId).filter(Boolean)).size },
        { 'Metric': 'Active Buyers', 'Value': new Set(allTransactions.map(t => t.buyerId).filter(Boolean)).size },
        { 'Metric': 'Completed', 'Value': allTransactions.filter(t => t.transactionStatus === 'COMPLETED').length },
        { 'Metric': 'Pending', 'Value': allTransactions.filter(t => t.transactionStatus === 'PENDING').length }
    ];

    const ws1 = XLSX.utils.json_to_sheet(statsData);
    ws1['!cols'] = [{ wch: 30 }, { wch: 20 }];
    XLSX.utils.book_append_sheet(wb, ws1, 'Statistics');

    // Transactions Details Sheet
    const transData = allTransactions.map((t, i) => {
        const crop = allCrops.find(c => c.id === t.cropId);
        const farmer = allUsers.find(u => u.id === t.farmerId);
        const buyer = allUsers.find(u => u.id === t.buyerId);

        return {
            '#': i + 1,
            'Transaction ID': t.id || 'N/A',
            'Date': formatDate(t.createdAt),
            'Farmer': farmer ? `${farmer.firstName} ${farmer.lastName}` : 'Unknown',
            'Buyer': buyer ? `${buyer.firstName} ${buyer.lastName}` : 'Unknown',
            'Crop': crop ? crop.cropName : 'Unknown',
            'Quantity': parseFloat(t.quantity) || 0,
            'Unit': t.unit || 'kg',
            'Price per Unit (RWF)': parseFloat(t.pricePerUnit) || 0,
            'Total Amount (RWF)': parseFloat(t.totalAmount) || 0,
            'Status': formatEnum(t.transactionStatus),
            'Payment Method': formatEnum(t.paymentMethod),
            'Location': t.location || 'N/A'
        };
    });

    const ws2 = XLSX.utils.json_to_sheet(transData);
    ws2['!cols'] = [
        { wch: 5 }, { wch: 15 }, { wch: 12 }, { wch: 15 }, { wch: 15 },
        { wch: 15 }, { wch: 10 }, { wch: 8 }, { wch: 12 }, { wch: 15 },
        { wch: 12 }, { wch: 12 }, { wch: 15 }
    ];
    XLSX.utils.book_append_sheet(wb, ws2, 'Transaction Details');

    XLSX.writeFile(wb, `AgriGuard_Transactions_Report_${Date.now()}.xlsx`);
}

// ==================== CROPS EXCEL EXPORT ====================
async function exportCropsExcel() {
    const wb = XLSX.utils.book_new();

    const totalYield = allCropProductions.reduce((sum, cp) => sum + (parseFloat(cp.actualYield || cp.expectedYield) || 0), 0);
    const totalArea = allCropProductions.reduce((sum, cp) => sum + (parseFloat(cp.areaInHectares) || 0), 0);
    const avgYield = allCropProductions.length > 0 ? totalYield / allCropProductions.length : 0;

    // Statistics Sheet
    const statsData = [
        { 'Metric': 'Total Productions', 'Value': allCropProductions.length },
        { 'Metric': 'Total Area', 'Value': `${totalArea.toFixed(1)} hectares` },
        { 'Metric': 'Total Yield', 'Value': `${totalYield.toFixed(1)} tons` },
        { 'Metric': 'Average Yield', 'Value': `${avgYield.toFixed(2)} tons/ha` },
        { 'Metric': 'Harvested', 'Value': allCropProductions.filter(cp => cp.productionStatus === 'HARVESTED').length },
        { 'Metric': 'Growing', 'Value': allCropProductions.filter(cp => cp.productionStatus === 'GROWING').length },
        { 'Metric': 'Planted', 'Value': allCropProductions.filter(cp => cp.productionStatus === 'PLANTED').length },
        { 'Metric': 'Unique Crops', 'Value': new Set(allCropProductions.map(cp => cp.cropId)).size }
    ];

    const ws1 = XLSX.utils.json_to_sheet(statsData);
    ws1['!cols'] = [{ wch: 25 }, { wch: 20 }];
    XLSX.utils.book_append_sheet(wb, ws1, 'Statistics');

    // Crop Production Details Sheet
    const cropData = allCropProductions.map((cp, i) => {
        const crop = allCrops.find(c => c.id === cp.cropId);
        const farmer = allUsers.find(u => u.id === cp.farmerId);

        return {
            '#': i + 1,
            'Production ID': cp.id || 'N/A',
            'Farmer': farmer ? `${farmer.firstName} ${farmer.lastName}` : 'Unknown',
            'Crop': crop ? crop.cropName : 'Unknown',
            'Season': cp.season || 'N/A',
            'Area (hectares)': parseFloat(cp.areaInHectares) || 0,
            'Expected Yield (t/ha)': parseFloat(cp.expectedYield) || 0,
            'Actual Yield (t/ha)': parseFloat(cp.actualYield) || 0,
            'Status': formatEnum(cp.productionStatus),
            'Planting Date': formatDate(cp.plantingDate),
            'Harvest Date': formatDate(cp.harvestDate),
            'Location': cp.location || 'N/A',
            'Notes': cp.notes || ''
        };
    });

    const ws2 = XLSX.utils.json_to_sheet(cropData);
    ws2['!cols'] = [
        { wch: 5 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 10 },
        { wch: 12 }, { wch: 15 }, { wch: 15 }, { wch: 12 }, { wch: 12 },
        { wch: 12 }, { wch: 15 }, { wch: 30 }
    ];
    XLSX.utils.book_append_sheet(wb, ws2, 'Production Details');

    XLSX.writeFile(wb, `AgriGuard_Crops_Report_${Date.now()}.xlsx`);
}

// ==================== MARKET EXCEL EXPORT ====================
async function exportMarketExcel() {
    const wb = XLSX.utils.book_new();

    const avgPrice = allMarketPrices.length > 0
        ? allMarketPrices.reduce((sum, mp) => sum + (parseFloat(mp.pricePerKg) || 0), 0) / allMarketPrices.length
        : 0;
    const maxPrice = Math.max(...allMarketPrices.map(mp => parseFloat(mp.pricePerKg) || 0));
    const minPrice = Math.min(...allMarketPrices.map(mp => parseFloat(mp.pricePerKg) || 0));

    // Statistics Sheet
    const statsData = [
        { 'Metric': 'Total Price Records', 'Value': allMarketPrices.length },
        { 'Metric': 'Average Price', 'Value': `RWF ${avgPrice.toFixed(2)}/kg` },
        { 'Metric': 'Highest Price', 'Value': `RWF ${maxPrice.toFixed(2)}/kg` },
        { 'Metric': 'Lowest Price', 'Value': `RWF ${minPrice.toFixed(2)}/kg` },
        { 'Metric': 'Unique Locations', 'Value': new Set(allMarketPrices.map(mp => mp.location)).size },
        { 'Metric': 'High Demand Items', 'Value': allMarketPrices.filter(mp => mp.demandLevel === 'HIGH' || mp.demandLevel === 'VERY_HIGH').length },
        { 'Metric': 'Low Supply Items', 'Value': allMarketPrices.filter(mp => mp.supplyLevel === 'LOW').length },
        { 'Metric': 'Tracked Crops', 'Value': new Set(allMarketPrices.map(mp => mp.cropId)).size }
    ];

    const ws1 = XLSX.utils.json_to_sheet(statsData);
    ws1['!cols'] = [{ wch: 25 }, { wch: 20 }];
    XLSX.utils.book_append_sheet(wb, ws1, 'Statistics');

    // Market Price Details Sheet
    const marketData = allMarketPrices.map((mp, i) => {
        const crop = allCrops.find(c => c.id === mp.cropId);

        return {
            '#': i + 1,
            'Record ID': mp.id || 'N/A',
            'Crop': crop ? crop.cropName : 'Unknown',
            'Price (RWF/kg)': parseFloat(mp.pricePerKg) || 0,
            'Location': mp.location || 'N/A',
            'Demand Level': formatEnum(mp.demandLevel),
            'Supply Level': formatEnum(mp.supplyLevel),
            'Market Condition': formatEnum(mp.marketCondition),
            'Quality Grade': mp.qualityGrade || 'N/A',
            'Date': formatDate(mp.priceDate),
            'Source': mp.source || 'N/A',
            'Notes': mp.notes || ''
        };
    });

    const ws2 = XLSX.utils.json_to_sheet(marketData);
    ws2['!cols'] = [
        { wch: 5 }, { wch: 15 }, { wch: 15 }, { wch: 12 }, { wch: 15 },
        { wch: 12 }, { wch: 12 }, { wch: 15 }, { wch: 12 }, { wch: 12 },
        { wch: 15 }, { wch: 30 }
    ];
    XLSX.utils.book_append_sheet(wb, ws2, 'Market Price Details');

    XLSX.writeFile(wb, `AgriGuard_Market_Report_${Date.now()}.xlsx`);
}

// ==================== WEATHER EXCEL EXPORT ====================
async function exportWeatherExcel() {
    const wb = XLSX.utils.book_new();

    const avgTemp = allWeatherData.length > 0
        ? allWeatherData.reduce((sum, w) => sum + (parseFloat(w.temperature) || 0), 0) / allWeatherData.length
        : 0;
    const totalRainfall = allWeatherData.reduce((sum, w) => sum + (parseFloat(w.rainfall) || 0), 0);
    const avgHumidity = allWeatherData.length > 0
        ? allWeatherData.reduce((sum, w) => sum + (parseFloat(w.humidity) || 0), 0) / allWeatherData.length
        : 0;
    const avgWindSpeed = allWeatherData.length > 0
        ? allWeatherData.reduce((sum, w) => sum + (parseFloat(w.windSpeed) || 0), 0) / allWeatherData.length
        : 0;

    // Statistics Sheet
    const statsData = [
        { 'Metric': 'Total Weather Records', 'Value': allWeatherData.length },
        { 'Metric': 'Average Temperature', 'Value': `${avgTemp.toFixed(1)}Â°C` },
        { 'Metric': 'Total Rainfall', 'Value': `${totalRainfall.toFixed(1)} mm` },
        { 'Metric': 'Average Humidity', 'Value': `${avgHumidity.toFixed(0)}%` },
        { 'Metric': 'Average Wind Speed', 'Value': `${avgWindSpeed.toFixed(1)} m/s` },
        { 'Metric': 'Optimal Days', 'Value': allWeatherData.filter(w => {
            const temp = parseFloat(w.temperature) || 0;
            const hum = parseFloat(w.humidity) || 0;
            return temp >= 20 && temp <= 30 && hum >= 40 && hum <= 70;
        }).length }
    ];

    const ws1 = XLSX.utils.json_to_sheet(statsData);
    ws1['!cols'] = [{ wch: 25 }, { wch: 20 }];
    XLSX.utils.book_append_sheet(wb, ws1, 'Statistics');

    // Weather Data Details Sheet
    const weatherData = allWeatherData.map((w, i) => {
        return {
            '#': i + 1,
            'Record ID': w.id || 'N/A',
            'Date': formatDate(w.measurementDate || w.recordDate),
            'Temperature (Â°C)': parseFloat(w.temperature) || 0,
            'Rainfall (mm)': parseFloat(w.rainfall) || 0,
            'Humidity (%)': parseFloat(w.humidity) || 0,
            'Wind Speed (m/s)': parseFloat(w.windSpeed) || 0,
            'Condition': formatEnum(w.weatherCondition),
            'Location': w.location || 'N/A',
            'UV Index': parseFloat(w.uvIndex) || 0,
            'Pressure (hPa)': parseFloat(w.pressure) || 0,
            'Notes': w.notes || ''
        };
    });

    const ws2 = XLSX.utils.json_to_sheet(weatherData);
    ws2['!cols'] = [
        { wch: 5 }, { wch: 15 }, { wch: 12 }, { wch: 12 }, { wch: 12 },
        { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 15 }, { wch: 10 },
        { wch: 12 }, { wch: 30 }
    ];
    XLSX.utils.book_append_sheet(wb, ws2, 'Weather Data Details');

    XLSX.writeFile(wb, `AgriGuard_Weather_Report_${Date.now()}.xlsx`);
}

// ==================== SOIL EXCEL EXPORT ====================
async function exportSoilExcel() {
    const wb = XLSX.utils.book_new();

    const avgQuality = calculateAverageSoilQuality();
    const avgPH = allSoilData.length > 0
        ? allSoilData.reduce((sum, sd) => sum + (parseFloat(sd.phLevel) || 0), 0) / allSoilData.length
        : 0;
    const avgNitrogen = allSoilData.length > 0
        ? allSoilData.reduce((sum, sd) => sum + (parseFloat(sd.nitrogen) || 0), 0) / allSoilData.length
        : 0;
    const avgPhosphorus = allSoilData.length > 0
        ? allSoilData.reduce((sum, sd) => sum + (parseFloat(sd.phosphorus) || 0), 0) / allSoilData.length
        : 0;
    const avgPotassium = allSoilData.length > 0
        ? allSoilData.reduce((sum, sd) => sum + (parseFloat(sd.potassium) || 0), 0) / allSoilData.length
        : 0;

    // Statistics Sheet
    const statsData = [
        { 'Metric': 'Total Soil Samples', 'Value': allSoilData.length },
        { 'Metric': 'Average Soil Quality', 'Value': `${avgQuality.toFixed(0)}%` },
        { 'Metric': 'Average pH Level', 'Value': avgPH.toFixed(2) },
        { 'Metric': 'Average Nitrogen', 'Value': `${avgNitrogen.toFixed(1)} ppm` },
        { 'Metric': 'Average Phosphorus', 'Value': `${avgPhosphorus.toFixed(1)} ppm` },
        { 'Metric': 'Average Potassium', 'Value': `${avgPotassium.toFixed(1)} ppm` },
        { 'Metric': 'Healthy Samples', 'Value': allSoilData.filter(sd => {
            const ph = parseFloat(sd.phLevel) || 0;
            return ph >= 6.0 && ph <= 7.5;
        }).length }
    ];

    const ws1 = XLSX.utils.json_to_sheet(statsData);
    ws1['!cols'] = [{ wch: 25 }, { wch: 20 }];
    XLSX.utils.book_append_sheet(wb, ws1, 'Statistics');

    // Soil Data Details Sheet
    const soilData = allSoilData.map((sd, i) => {
        const farmer = allUsers.find(u => u.id === sd.farmerId);

        return {
            '#': i + 1,
            'Sample ID': sd.id || 'N/A',
            'Farmer': farmer ? `${farmer.firstName} ${farmer.lastName}` : 'Unknown',
            'Date': formatDate(sd.measurementDate || sd.createdAt),
            'pH Level': parseFloat(sd.phLevel) || 0,
            'Nitrogen (ppm)': parseFloat(sd.nitrogen) || 0,
            'Phosphorus (ppm)': parseFloat(sd.phosphorus) || 0,
            'Potassium (ppm)': parseFloat(sd.potassium) || 0,
            'Organic Matter (%)': parseFloat(sd.organicMatter) || 0,
            'Soil Texture': formatEnum(sd.soilTexture),
            'Moisture (%)': parseFloat(sd.moisture) || 0,
            'Location': sd.location || 'N/A',
            'Recommendations': sd.recommendations || '',
            'Notes': sd.notes || ''
        };
    });

    const ws2 = XLSX.utils.json_to_sheet(soilData);
    ws2['!cols'] = [
        { wch: 5 }, { wch: 15 }, { wch: 15 }, { wch: 12 }, { wch: 10 },
        { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 },
        { wch: 10 }, { wch: 15 }, { wch: 30 }, { wch: 30 }
    ];
    XLSX.utils.book_append_sheet(wb, ws2, 'Soil Analysis Details');

    XLSX.writeFile(wb, `AgriGuard_Soil_Report_${Date.now()}.xlsx`);
}

// ==================== PREDICTIONS EXCEL EXPORT ====================
async function exportPredictionsExcel() {
    const wb = XLSX.utils.book_new();

    const predictedYield = allCropProductions.length * 2.5;
    const avgSoilQuality = calculateAverageSoilQuality();

    // AI Predictions Sheet
    const predictionsData = [
        {
            'Category': 'Crop Yield',
            'Prediction': `${predictedYield.toFixed(1)} tons`,
            'Confidence': '85%',
            'Time Frame': 'Next 30-60 days',
            'Status': 'Favorable'
        },
        {
            'Category': 'Market Price',
            'Prediction': 'Upward trend (+5-8%)',
            'Confidence': '78%',
            'Time Frame': 'Next 2-3 weeks',
            'Status': 'Positive'
        },
        {
            'Category': 'Weather Impact',
            'Prediction': 'Low to Medium risk',
            'Confidence': '82%',
            'Time Frame': 'Next 7-14 days',
            'Status': 'Monitor'
        },
        {
            'Category': 'Soil Health',
            'Prediction': `${avgSoilQuality.toFixed(0)}% quality`,
            'Confidence': '90%',
            'Time Frame': 'Current',
            'Status': avgSoilQuality > 70 ? 'Good' : 'Needs Improvement'
        }
    ];

    const ws1 = XLSX.utils.json_to_sheet(predictionsData);
    ws1['!cols'] = [{ wch: 15 }, { wch: 20 }, { wch: 12 }, { wch: 15 }, { wch: 15 }];
    XLSX.utils.book_append_sheet(wb, ws1, 'AI Predictions');

    // Recommendations Sheet
    const recommendations = [
        {
            'Priority': 'High',
            'Area': 'Crop Management',
            'Recommendation': 'Monitor growing crops closely for optimal harvest timing',
            'Expected Impact': 'Maximize yield quality'
        },
        {
            'Priority': 'High',
            'Area': 'Market Strategy',
            'Recommendation': 'Consider selling in 2-3 weeks to capitalize on price uptrend',
            'Expected Impact': 'Increased revenue by 5-8%'
        },
        {
            'Priority': 'Medium',
            'Area': 'Weather Preparedness',
            'Recommendation': 'Ensure adequate irrigation systems are functional',
            'Expected Impact': 'Reduce weather-related crop stress'
        },
        {
            'Priority': 'Medium',
            'Area': 'Soil Management',
            'Recommendation': 'Maintain current soil nutrient levels through regular testing',
            'Expected Impact': 'Sustained soil health'
        },
        {
            'Priority': 'Low',
            'Area': 'Planning',
            'Recommendation': 'Begin planning next season crop rotation',
            'Expected Impact': 'Improved long-term productivity'
        }
    ];

    const ws2 = XLSX.utils.json_to_sheet(recommendations);
    ws2['!cols'] = [{ wch: 10 }, { wch: 15 }, { wch: 50 }, { wch: 30 }];
    XLSX.utils.book_append_sheet(wb, ws2, 'Recommendations');

    XLSX.writeFile(wb, `AgriGuard_Predictions_Report_${Date.now()}.xlsx`);
}

// ==================== NAVIGATION ====================
function showSection(sectionName) {
    document.querySelectorAll('.content-section').forEach(section => {
        section.classList.remove('active');
    });

    const section = document.getElementById(sectionName + 'Section');
    if (section) {
        section.classList.add('active');
    }

    document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
    });

    const clickedItem = event.target.closest('.nav-item');
    if (clickedItem) {
        clickedItem.classList.add('active');
    }
}

function toggleSidebar() {
    document.getElementById('sidebar').classList.toggle('collapsed');
    document.getElementById('mainContent').classList.toggle('sidebar-collapsed');
}

function toggleTheme() {
    document.body.classList.toggle('dark-mode');
    const isDark = document.body.classList.contains('dark-mode');
    document.getElementById('themeToggle').innerHTML = isDark
        ? '<i class="fas fa-sun"></i><span>Light Mode</span>'
        : '<i class="fas fa-moon"></i><span>Dark Mode</span>';
    localStorage.setItem('theme', isDark ? 'dark' : 'light');
}

function loadSavedTheme() {
    if (localStorage.getItem('theme') === 'dark') {
        document.body.classList.add('dark-mode');
        document.getElementById('themeToggle').innerHTML =
            '<i class="fas fa-sun"></i><span>Light Mode</span>';
    }
}

function updateDateTime() {
    const now = new Date();
    const dateOptions = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    };
    document.getElementById('currentDate').textContent =
        now.toLocaleDateString('en-US', dateOptions);
}

// ==================== UTILITY FUNCTIONS ====================
function formatCurrency(value) {
    if (!value) return 'RWF 0';
    return `RWF ${parseFloat(value).toLocaleString('en-US', {
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
    })}`;
}

function formatDate(dateString) {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    });
}

function formatEnum(value) {
    if (!value) return 'N/A';
    return value.split('_')
        .map(word => word.charAt(0) + word.slice(1).toLowerCase())
        .join(' ');
}

function showLoading(show) {
    document.getElementById('loadingOverlay').classList.toggle('show', show);
}

function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.innerHTML = `<p>${message}</p>`;
    document.getElementById('toastContainer').appendChild(toast);
    setTimeout(() => toast.remove(), 5000);
}

console.log('Analyst Dashboard initialized successfully');

// ==================== AI ASSISTANT CHAT ====================
let chatHistory = [];

function handleChatInputKey(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendChatMessage();
    } else if (event.key === 'Enter' && event.shiftKey) {
        const textarea = event.target;
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
}

function askQuickQuestion(type) {
    const questions = {
        weather: "Predict next month's weather patterns and their impact on crops",
        soil: "Analyze soil health trends and predict future soil quality",
        market: "Forecast market prices for the top 5 crops for the next 30 days",
        yield: "Predict crop yields for the current season based on all data",
        irrigation: "Analyze irrigation needs and predict optimal watering schedules",
        security: "Assess food security situation and predict potential risks",
        comprehensive: "Provide a comprehensive prediction analysis of all factors"
    };

    const chatInput = document.getElementById('chatInput');
    chatInput.value = questions[type] || questions.comprehensive;
    sendChatMessage();
}

async function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const message = chatInput.value.trim();

    if (!message) return;

    const sendBtn = document.getElementById('chatSendBtn');
    sendBtn.disabled = true;

    // Add user message
    addMessageToChat('user', message);
    chatInput.value = '';
    chatInput.style.height = 'auto';

    // Show typing indicator
    const typingId = addTypingIndicator();

    // Generate AI response
    try {
        const response = await generateAIResponse(message);
        removeTypingIndicator(typingId);
        addMessageToChat('ai', response.text, response.chartId, response.data);
    } catch (error) {
        removeTypingIndicator(typingId);
        addMessageToChat('ai', 'Sorry, I encountered an error processing your request. Please try again.');
        console.error('AI Chat Error:', error);
    } finally {
        sendBtn.disabled = false;
        chatInput.focus();
    }
}

function addMessageToChat(type, text, chartId = null, chartData = null) {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}`;

    const avatarIcon = type === 'user' ? 'fas fa-user' : 'fas fa-robot';
    const time = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

    let chartHtml = '';
    if (chartId && chartData) {
        chartHtml = `<div class="message-chart"><canvas id="${chartId}"></canvas></div>`;
    }

    messageDiv.innerHTML = `
        <div class="message-avatar">
            <i class="${avatarIcon}"></i>
        </div>
        <div class="message-content">
            <div class="message-text">${text}</div>
            ${chartHtml}
            <div class="message-time">${time}</div>
        </div>
    `;

    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;

    // Initialize chart if provided
    if (chartId && chartData) {
        setTimeout(() => {
            initializePredictionChart(chartId, chartData);
        }, 100);
    }

    chatHistory.push({ type, text, time, chartId });
}

function addTypingIndicator() {
    const chatMessages = document.getElementById('chatMessages');
    const typingDiv = document.createElement('div');
    const typingId = 'typing-' + Date.now();
    typingDiv.id = typingId;
    typingDiv.className = 'message ai';

    typingDiv.innerHTML = `
        <div class="message-avatar">
            <i class="fas fa-robot"></i>
        </div>
        <div class="message-content">
            <div class="message-text">
                <div class="loading-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
    `;

    chatMessages.appendChild(typingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;

    return typingId;
}

function removeTypingIndicator(id) {
    const typingDiv = document.getElementById(id);
    if (typingDiv) typingDiv.remove();
}

async function generateAIResponse(userMessage) {
    const message = userMessage.toLowerCase();

    // Analyze the user's intent
    if (message.includes('weather') || message.includes('temperature') || message.includes('rainfall') || message.includes('rain')) {
        return await generateWeatherPrediction(message);
    } else if (message.includes('soil') || message.includes('ph') || message.includes('nutrient')) {
        return await generateSoilPrediction(message);
    } else if (message.includes('market') || message.includes('price') || message.includes('cost')) {
        return await generateMarketPrediction(message);
    } else if (message.includes('yield') || message.includes('crop') || message.includes('production') || message.includes('harvest')) {
        return await generateYieldPrediction(message);
    } else if (message.includes('irrigation') || message.includes('water') || message.includes('moisture')) {
        return await generateIrrigationPrediction(message);
    } else if (message.includes('food security') || message.includes('security') || message.includes('food')) {
        return await generateFoodSecurityPrediction(message);
    } else if (message.includes('farmer') || message.includes('farmer') || message.includes('user')) {
        return await generateFarmerAnalysis(message);
    } else if (message.includes('comprehensive') || message.includes('full') || message.includes('all') || message.includes('overview')) {
        return await generateComprehensivePrediction(message);
    } else {
        return await generateGeneralAnalysis(userMessage);
    }
}

async function generateWeatherPrediction(message) {
    if (allWeatherData.length === 0) {
        return {
            text: 'â Insufficient weather data available for prediction. Please ensure weather data is being collected.',
            chartId: null,
            data: null
        };
    }

    const recent = allWeatherData.slice(-30);
    const avgTemp = recent.reduce((sum, w) => sum + (parseFloat(w.temperature) || 0), 0) / recent.length;
    const avgRainfall = recent.reduce((sum, w) => sum + (parseFloat(w.rainfall) || 0), 0) / recent.length;
    const avgHumidity = recent.reduce((sum, w) => sum + (parseFloat(w.humidity) || 0), 0) / recent.length;

    // Predict next 30 days using trend analysis
    const tempTrend = calculateTrend(recent.map(w => parseFloat(w.temperature) || 0));
    const rainfallTrend = calculateTrend(recent.map(w => parseFloat(w.rainfall) || 0));

    const predictedTemp = avgTemp + (tempTrend * 30);
    const predictedRainfall = Math.max(0, avgRainfall + (rainfallTrend * 30));

    const chartId = 'weather-chart-' + Date.now();
    const chartData = {
        type: 'line',
        labels: ['Last 7 Days', 'Last 14 Days', 'Last 30 Days', 'Predicted (Next 30 Days)'],
        datasets: [{
            label: 'Temperature (Â°C)',
            data: [
                recent.slice(-7).reduce((s, w) => s + (parseFloat(w.temperature) || 0), 0) / 7,
                recent.slice(-14).reduce((s, w) => s + (parseFloat(w.temperature) || 0), 0) / 14,
                avgTemp,
                predictedTemp
            ],
            borderColor: '#ef4444',
            backgroundColor: 'rgba(239, 68, 68, 0.1)',
            tension: 0.4
        }, {
            label: 'Rainfall (mm)',
            data: [
                recent.slice(-7).reduce((s, w) => s + (parseFloat(w.rainfall) || 0), 0) / 7,
                recent.slice(-14).reduce((s, w) => s + (parseFloat(w.rainfall) || 0), 0) / 14,
                avgRainfall,
                predictedRainfall
            ],
            borderColor: '#3b82f6',
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            tension: 0.4,
            yAxisID: 'y1'
        }]
    };

    let riskLevel = 'Low';
    let riskColor = 'ð¢';
    if (predictedTemp > 35 || predictedTemp < 15 || predictedRainfall > 50) {
        riskLevel = 'High';
        riskColor = 'ð´';
    } else if (predictedTemp > 32 || predictedTemp < 18 || predictedRainfall > 30) {
        riskLevel = 'Medium';
        riskColor = 'ð¡';
    }

    const text = `
        <div class="prediction-card">
            <div class="prediction-title">ð¤ï¸ Weather Prediction (Next 30 Days)</div>
            <div style="margin: 12px 0;">
                <strong>Temperature:</strong> ${predictedTemp.toFixed(1)}Â°C (Current avg: ${avgTemp.toFixed(1)}Â°C)<br>
                <strong>Rainfall:</strong> ${predictedRainfall.toFixed(1)}mm (Current avg: ${avgRainfall.toFixed(1)}mm)<br>
                <strong>Humidity:</strong> ${avgHumidity.toFixed(1)}%<br>
                <strong>Risk Level:</strong> ${riskColor} ${riskLevel}
            </div>
            <div class="prediction-details">
                <strong>Analysis:</strong> Based on ${allWeatherData.length} weather records, the trend indicates ${tempTrend >= 0 ? 'warming' : 'cooling'} temperatures
                and ${rainfallTrend >= 0 ? 'increasing' : 'decreasing'} rainfall.
                ${riskLevel === 'High' ? 'â ï¸ Extreme weather conditions predicted - take preventive measures.' : 'â Conditions appear favorable for agricultural activities.'}
            </div>
        </div>
    `;

    return { text, chartId, data: chartData };
}

async function generateSoilPrediction(message) {
    if (allSoilData.length === 0) {
        return {
            text: 'â Insufficient soil data available for prediction.',
            chartId: null,
            data: null
        };
    }

    const avgQuality = calculateAverageSoilQuality();
    const avgN = allSoilData.reduce((sum, s) => sum + (parseFloat(s.nitrogen) || 0), 0) / allSoilData.length;
    const avgP = allSoilData.reduce((sum, s) => sum + (parseFloat(s.phosphorus) || 0), 0) / allSoilData.length;
    const avgK = allSoilData.reduce((sum, s) => sum + (parseFloat(s.potassium) || 0), 0) / allSoilData.length;
    const avgPH = allSoilData.reduce((sum, s) => sum + (parseFloat(s.phLevel) || 0), 0) / allSoilData.length;

    // Predict future soil quality based on current trends
    const predictedQuality = Math.min(100, avgQuality + (avgQuality > 70 ? 2 : 5));

    const chartId = 'soil-chart-' + Date.now();
    const chartData = {
        type: 'radar',
        labels: ['pH Level', 'Nitrogen', 'Phosphorus', 'Potassium', 'Organic Matter', 'Overall Quality'],
        datasets: [{
            label: 'Current Levels',
            data: [
                (avgPH / 14) * 100,
                Math.min(100, (avgN / 150) * 100),
                Math.min(100, (avgP / 100) * 100),
                Math.min(100, (avgK / 500) * 100),
                Math.min(100, allSoilData.reduce((s, d) => s + (parseFloat(d.organicMatter) || 0), 0) / allSoilData.length * 10),
                avgQuality
            ],
            borderColor: '#22c55e',
            backgroundColor: 'rgba(34, 197, 94, 0.2)',
            borderWidth: 2
        }, {
            label: 'Predicted (Next Season)',
            data: [
                (avgPH / 14) * 100,
                Math.min(100, ((avgN + 10) / 150) * 100),
                Math.min(100, ((avgP + 5) / 100) * 100),
                Math.min(100, ((avgK + 20) / 500) * 100),
                Math.min(100, allSoilData.reduce((s, d) => s + (parseFloat(d.organicMatter) || 0), 0) / allSoilData.length * 10 + 2),
                predictedQuality
            ],
            borderColor: '#3b82f6',
            backgroundColor: 'rgba(59, 130, 246, 0.2)',
            borderWidth: 2
        }]
    };

    const text = `
        <div class="prediction-card">
            <div class="prediction-title">ð± Soil Health Prediction</div>
            <div style="margin: 12px 0;">
                <strong>Current Quality Score:</strong> ${avgQuality.toFixed(1)}%<br>
                <strong>Predicted Quality (Next Season):</strong> ${predictedQuality.toFixed(1)}%<br>
                <strong>NPK Levels:</strong> N=${avgN.toFixed(1)}ppm, P=${avgP.toFixed(1)}ppm, K=${avgK.toFixed(1)}ppm<br>
                <strong>pH Level:</strong> ${avgPH.toFixed(1)}
            </div>
            <div class="prediction-details">
                <strong>Recommendations:</strong> Based on ${allSoilData.length} soil samples,
                ${avgQuality < 70 ? 'soil quality needs improvement. Consider organic fertilizers and crop rotation.' : 'soil health is good. Maintain current practices.'}
                ${avgN < 40 || avgP < 25 || avgK < 150 ? ' Nutrient deficiencies detected - fertilization recommended.' : ''}
            </div>
        </div>
    `;

    return { text, chartId, data: chartData };
}

async function generateMarketPrediction(message) {
    if (allMarketPrices.length === 0) {
        return {
            text: 'â Insufficient market price data available for prediction.',
            chartId: null,
            data: null
        };
    }

    const recent = allMarketPrices.slice(-30).sort((a, b) => new Date(b.priceDate) - new Date(a.priceDate));
    const topCrops = getTopCropsByPrice(5);

    const chartId = 'market-chart-' + Date.now();
    const labels = topCrops[0] ? topCrops[0].dates : [];
    const datasets = topCrops.map((crop, idx) => {
        const colors = ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6'];
        const recentPrices = crop.prices.slice(-30);
        const trend = calculateTrend(recentPrices);
        const currentPrice = recentPrices[recentPrices.length - 1] || 0;
        const predictedPrice = Math.max(0, currentPrice * (1 + trend * 0.1));

        return {
            label: crop.name + ' (Predicted)',
            data: [...crop.prices, predictedPrice],
            borderColor: colors[idx % colors.length],
            backgroundColor: colors[idx % colors.length] + '20',
            tension: 0.4,
            borderDash: [0, 0, 5, 5]
        };
    });

    const chartData = {
        type: 'line',
        labels: [...labels, 'Predicted'],
        datasets: datasets
    };

    let predictionsText = topCrops.map((crop, idx) => {
        const recentPrices = crop.prices.slice(-30);
        const currentPrice = recentPrices[recentPrices.length - 1] || 0;
        const trend = calculateTrend(recentPrices);
        const predictedPrice = Math.max(0, currentPrice * (1 + trend * 0.1));
        const change = ((predictedPrice - currentPrice) / currentPrice) * 100;

        return `${crop.name}: ${formatCurrency(currentPrice)} â ${formatCurrency(predictedPrice)} (${change >= 0 ? '+' : ''}${change.toFixed(1)}%)`;
    }).join('<br>');

    const text = `
        <div class="prediction-card">
            <div class="prediction-title">ð° Market Price Forecast (Next 30 Days)</div>
            <div style="margin: 12px 0;">
                ${predictionsText}
            </div>
            <div class="prediction-details">
                <strong>Analysis:</strong> Based on ${allMarketPrices.length} price records, market trends show
                ${topCrops.some(c => calculateTrend(c.prices) > 0) ? 'upward' : 'downward'} momentum for most crops.
                Consider timing your sales during price peaks for optimal revenue.
            </div>
        </div>
    `;

    return { text, chartId, data: chartData };
}

async function generateYieldPrediction(message) {
    if (allCropProductions.length === 0) {
        return {
            text: 'â Insufficient crop production data available for prediction.',
            chartId: null,
            data: null
        };
    }

    const harvested = allCropProductions.filter(cp => cp.productionStatus === 'HARVESTED' && cp.actualYield);
    const active = allCropProductions.filter(cp => cp.productionStatus === 'PLANTED' || cp.productionStatus === 'GROWING');

    const avgYield = harvested.length > 0
        ? harvested.reduce((sum, cp) => sum + (parseFloat(cp.actualYield) || 0), 0) / harvested.length
        : 0;

    const totalArea = active.reduce((sum, cp) => sum + (parseFloat(cp.areaInHectares) || 0), 0);
    const avgSoilQuality = calculateAverageSoilQuality();
    const weatherScore = calculateWeatherScore();

    const predictedYield = avgYield * totalArea * (avgSoilQuality / 100) * (weatherScore / 100);

    const chartId = 'yield-chart-' + Date.now();
    const cropYieldData = {};
    harvested.forEach(cp => {
        const cropId = cp.cropId;
        if (!cropYieldData[cropId]) cropYieldData[cropId] = [];
        cropYieldData[cropId].push(parseFloat(cp.actualYield) || 0);
    });

    const topCrops = Object.entries(cropYieldData)
        .map(([cropId, yields]) => {
            const crop = allCrops.find(c => c.id === cropId);
            return {
                name: crop ? crop.cropName : 'Unknown',
                avgYield: yields.reduce((a, b) => a + b, 0) / yields.length
            };
        })
        .sort((a, b) => b.avgYield - a.avgYield)
        .slice(0, 5);

    const chartData = {
        type: 'bar',
        labels: topCrops.map(c => c.name),
        datasets: [{
            label: 'Average Yield (tons/ha)',
            data: topCrops.map(c => c.avgYield),
            backgroundColor: '#22c55e'
        }]
    };

    const text = `
        <div class="prediction-card">
            <div class="prediction-title">ð¾ Crop Yield Prediction</div>
            <div style="margin: 12px 0;">
                <strong>Active Productions:</strong> ${active.length}<br>
                <strong>Total Area:</strong> ${totalArea.toFixed(1)} hectares<br>
                <strong>Predicted Total Yield:</strong> <span class="prediction-value">${predictedYield.toFixed(1)} tons</span><br>
                <strong>Average Yield per Hectare:</strong> ${avgYield.toFixed(2)} tons/ha<br>
                <strong>Confidence:</strong> ${Math.min(95, 60 + (harvested.length / 10) * 10).toFixed(0)}%
            </div>
            <div class="prediction-details">
                <strong>Factors Considered:</strong> Historical yields (${harvested.length} records), soil quality (${avgSoilQuality.toFixed(0)}%),
                weather conditions (${weatherScore.toFixed(0)}% optimal).
                ${predictedYield > avgYield * totalArea ? 'ð Yield expected to exceed average.' : 'ð Yield may be below optimal - monitor conditions closely.'}
            </div>
        </div>
    `;

    return { text, chartId, data: chartData };
}

async function generateIrrigationPrediction(message) {
    if (allWeatherData.length === 0 || allSoilData.length === 0) {
        return {
            text: 'â Insufficient data for irrigation prediction.',
            chartId: null,
            data: null
        };
    }

    const recent = allWeatherData.slice(-7);
    const totalRainfall = recent.reduce((sum, w) => sum + (parseFloat(w.rainfall) || 0), 0);
    const avgMoisture = allSoilData.reduce((sum, s) => sum + (parseFloat(s.moisture) || 0), 0) / allSoilData.length;
    const avgTemp = recent.reduce((sum, w) => sum + (parseFloat(w.temperature) || 0), 0) / recent.length;

    const irrigationNeed = calculateIrrigationNeed(totalRainfall, avgMoisture, avgTemp);

    const chartId = 'irrigation-chart-' + Date.now();
    const chartData = {
        type: 'doughnut',
        labels: ['Sufficient Moisture', 'Irrigation Needed', 'Critical Need'],
        datasets: [{
            data: [
                irrigationNeed < 30 ? 70 : 30,
                irrigationNeed >= 30 && irrigationNeed < 70 ? 60 : 20,
                irrigationNeed >= 70 ? 80 : 10
            ],
            backgroundColor: ['#22c55e', '#f59e0b', '#ef4444']
        }]
    };

    let recommendation = '';
    let urgency = '';
    if (irrigationNeed > 70) {
        recommendation = 'URGENT: Increase irrigation immediately. Soil moisture critically low.';
        urgency = 'ð´ High Priority';
    } else if (irrigationNeed > 40) {
        recommendation = 'Moderate irrigation needed. Schedule additional watering.';
        urgency = 'ð¡ Medium Priority';
    } else {
        recommendation = 'Current irrigation adequate. Continue monitoring.';
        urgency = 'ð¢ Low Priority';
    }

    const text = `
        <div class="prediction-card">
            <div class="prediction-title">ð§ Irrigation Needs Prediction</div>
            <div style="margin: 12px 0;">
                <strong>7-Day Rainfall:</strong> ${totalRainfall.toFixed(1)}mm<br>
                <strong>Soil Moisture:</strong> ${avgMoisture.toFixed(1)}%<br>
                <strong>Temperature:</strong> ${avgTemp.toFixed(1)}Â°C<br>
                <strong>Irrigation Need Index:</strong> ${irrigationNeed.toFixed(0)}%<br>
                <strong>Priority:</strong> ${urgency}
            </div>
            <div class="prediction-details">
                <strong>Recommendation:</strong> ${recommendation}
                ${avgTemp > 30 ? ' High temperatures increase evaporation - prefer early morning/evening irrigation.' : ''}
            </div>
        </div>
    `;

    return { text, chartId, data: chartData };
}

async function generateFoodSecurityPrediction(message) {
    const totalTransactions = allTransactions.length;
    const totalRevenue = allTransactions.reduce((sum, t) => sum + (parseFloat(t.totalAmount) || 0), 0);
    const uniqueFarmers = new Set(allTransactions.map(t => t.farmerId).filter(Boolean)).size;
    const totalCropProductions = allCropProductions.length;
    const harvestedProductions = allCropProductions.filter(cp => cp.productionStatus === 'HARVESTED').length;

    const foodSecurityIndex = calculateFoodSecurityIndex(totalTransactions, uniqueFarmers, totalCropProductions, harvestedProductions);

    const chartId = 'security-chart-' + Date.now();
    const chartData = {
        type: 'bar',
        labels: ['Market Activity', 'Farmer Participation', 'Crop Production', 'Harvest Rate', 'Overall Security'],
        datasets: [{
            label: 'Index Score (%)',
            data: [
                Math.min(100, (totalTransactions / 1000) * 100),
                Math.min(100, (uniqueFarmers / 50) * 100),
                Math.min(100, (totalCropProductions / 200) * 100),
                totalCropProductions > 0 ? (harvestedProductions / totalCropProductions) * 100 : 0,
                foodSecurityIndex
            ],
            backgroundColor: ['#22c55e', '#3b82f6', '#f59e0b', '#8b5cf6', '#ef4444']
        }]
    };

    let securityLevel = 'Good';
    let securityEmoji = 'ð¢';
    if (foodSecurityIndex < 40) {
        securityLevel = 'Critical';
        securityEmoji = 'ð´';
    } else if (foodSecurityIndex < 60) {
        securityLevel = 'Moderate';
        securityEmoji = 'ð¡';
    }

    const text = `
        <div class="prediction-card">
            <div class="prediction-title">ð½ï¸ Food Security Analysis</div>
            <div style="margin: 12px 0;">
                <strong>Security Index:</strong> <span class="prediction-value">${foodSecurityIndex.toFixed(1)}%</span><br>
                <strong>Status:</strong> ${securityEmoji} ${securityLevel}<br>
                <strong>Active Farmers:</strong> ${uniqueFarmers}<br>
                <strong>Total Transactions:</strong> ${totalTransactions}<br>
                <strong>Crop Productions:</strong> ${totalCropProductions} (${harvestedProductions} harvested)
            </div>
            <div class="prediction-details">
                <strong>Assessment:</strong> ${foodSecurityIndex >= 70 ? 'Food security is strong with active market participation and good crop production rates.' :
                'Food security needs attention. Consider supporting farmer participation and improving production rates.'}
            </div>
        </div>
    `;

    return { text, chartId, data: chartData };
}

async function generateFarmerAnalysis(message) {
    const uniqueFarmers = new Set(allTransactions.map(t => t.farmerId).filter(Boolean));
    const farmerStats = {};

    uniqueFarmers.forEach(farmerId => {
        const farmerTransactions = allTransactions.filter(t => t.farmerId === farmerId);
        farmerStats[farmerId] = {
            transactions: farmerTransactions.length,
            revenue: farmerTransactions.reduce((sum, t) => sum + (parseFloat(t.totalAmount) || 0), 0),
            crops: new Set(farmerTransactions.map(t => t.cropId)).size
        };
    });

    const topFarmers = Object.entries(farmerStats)
        .sort((a, b) => b[1].revenue - a[1].revenue)
        .slice(0, 5);

    const chartId = 'farmer-chart-' + Date.now();
    const chartData = {
        type: 'bar',
        labels: topFarmers.map(([id]) => `Farmer ${id.substring(0, 8)}`),
        datasets: [{
            label: 'Total Revenue (RWF)',
            data: topFarmers.map(([, stats]) => stats.revenue),
            backgroundColor: '#22c55e'
        }]
    };

    const avgRevenue = Object.values(farmerStats).reduce((sum, stats) => sum + stats.revenue, 0) / uniqueFarmers.size;

    const text = `
        <div class="prediction-card">
            <div class="prediction-title">ð¨âð¾ Farmer Performance Analysis</div>
            <div style="margin: 12px 0;">
                <strong>Total Active Farmers:</strong> ${uniqueFarmers.size}<br>
                <strong>Average Revenue per Farmer:</strong> ${formatCurrency(avgRevenue)}<br>
                <strong>Total Market Value:</strong> ${formatCurrency(allTransactions.reduce((sum, t) => sum + (parseFloat(t.totalAmount) || 0), 0))}
            </div>
            <div class="prediction-details">
                <strong>Top Performers:</strong> Top 5 farmers account for significant market share.
                Consider best practices sharing and capacity building programs for all farmers.
            </div>
        </div>
    `;

    return { text, chartId, data: chartData };
}

async function generateComprehensivePrediction(message) {
    const weatherPred = await generateWeatherPrediction('weather');
    const soilPred = await generateSoilPrediction('soil');
    const marketPred = await generateMarketPrediction('market');
    const yieldPred = await generateYieldPrediction('yield');
    const securityPred = await generateFoodSecurityPrediction('security');

    const text = `
        <div class="prediction-card">
            <div class="prediction-title">ð Comprehensive AI Analysis</div>
            <div style="margin: 12px 0;">
                <strong>Complete System Overview:</strong><br><br>
                ${weatherPred.text.split('</div>')[0].split('<div')[1] ? '' : ''}
                ${soilPred.text.split('</div>')[0]}
                ${marketPred.text.split('</div>')[0]}
                ${yieldPred.text.split('</div>')[0]}
                ${securityPred.text.split('</div>')[0]}
            </div>
            <div class="prediction-details">
                <strong>Summary:</strong> This comprehensive analysis integrates all available data from weather, soil, market,
                production, and transaction systems to provide a holistic view of agricultural performance and predictions.
            </div>
        </div>
    `;

    // Create a comparison chart
    const chartId = 'comprehensive-chart-' + Date.now();
    const chartData = {
        type: 'bar',
        labels: ['Weather Risk', 'Soil Quality', 'Market Stability', 'Yield Potential', 'Food Security'],
        datasets: [{
            label: 'System Health Index (%)',
            data: [
                calculateWeatherScore(),
                calculateAverageSoilQuality(),
                75, // Market stability (placeholder calculation)
                70, // Yield potential
                calculateFoodSecurityIndex(
                    allTransactions.length,
                    new Set(allTransactions.map(t => t.farmerId).filter(Boolean)).size,
                    allCropProductions.length,
                    allCropProductions.filter(cp => cp.productionStatus === 'HARVESTED').length
                )
            ],
            backgroundColor: ['#ef4444', '#22c55e', '#3b82f6', '#f59e0b', '#8b5cf6']
        }]
    };

    return { text, chartId, data: chartData };
}

async function generateGeneralAnalysis(message) {
    return {
        text: `I understand you're asking: "${message}". To provide the best analysis, I can help with:<br><br>
        â¢ Weather predictions and forecasts<br>
        â¢ Soil health analysis and recommendations<br>
        â¢ Market price trends and forecasts<br>
        â¢ Crop yield predictions<br>
        â¢ Irrigation needs assessment<br>
        â¢ Food security analysis<br>
        â¢ Farmer performance metrics<br>
        â¢ Comprehensive system analysis<br><br>
        Try asking a specific question or use the quick action buttons above!`,
        chartId: null,
        data: null
    };
}
/**
 * Calculate weather score based on recent weather data
 * Returns a score from 0-100 indicating weather favorability
 */
function calculateWeatherScore() {
    if (allWeatherData.length === 0) return 70; // Default neutral score

    // Get recent weather data (last 30 days)
    const recent = allWeatherData
        .filter(w => {
            const date = new Date(w.measurementDate || w.recordDate);
            const now = new Date();
            const daysDiff = (now - date) / (1000 * 60 * 60 * 24);
            return daysDiff <= 30;
        });

    if (recent.length === 0) return 70;

    let totalScore = 0;

    recent.forEach(w => {
        const temp = parseFloat(w.temperature) || 0;
        const humidity = parseFloat(w.humidity) || 0;
        const rainfall = parseFloat(w.rainfall) || 0;

        let dayScore = 0;

        // Temperature scoring (optimal: 20-30Â°C)
        let tempScore = 0;
        if (temp >= 20 && temp <= 30) {
            tempScore = 100;
        } else if (temp >= 15 && temp <= 35) {
            tempScore = 70;
        } else if (temp >= 10 && temp <= 40) {
            tempScore = 40;
        } else {
            tempScore = 20;
        }

        // Humidity scoring (optimal: 40-70%)
        let humidityScore = 0;
        if (humidity >= 40 && humidity <= 70) {
            humidityScore = 100;
        } else if (humidity >= 30 && humidity <= 80) {
            humidityScore = 70;
        } else if (humidity >= 20 && humidity <= 90) {
            humidityScore = 40;
        } else {
            humidityScore = 20;
        }

        // Rainfall scoring (optimal: 2-10mm per day)
        let rainfallScore = 0;
        if (rainfall >= 2 && rainfall <= 10) {
            rainfallScore = 100;
        } else if (rainfall >= 1 && rainfall <= 15) {
            rainfallScore = 70;
        } else if (rainfall >= 0.5 && rainfall <= 20) {
            rainfallScore = 40;
        } else if (rainfall > 20) {
            rainfallScore = 30; // Too much rain
        } else {
            rainfallScore = 50; // No rain, but might be irrigation
        }

        // Average the three scores
        dayScore = (tempScore + humidityScore + rainfallScore) / 3;
        totalScore += dayScore;
    });

    const averageScore = totalScore / recent.length;
    return averageScore;
}
function calculateTrend(values) {
    if (values.length < 2) return 0;
    const first = values.slice(0, Math.floor(values.length / 2)).reduce((a, b) => a + b, 0) / Math.floor(values.length / 2);
    const second = values.slice(Math.floor(values.length / 2)).reduce((a, b) => a + b, 0) / Math.ceil(values.length / 2);
    return (second - first) / first;
}

function calculateIrrigationNeed(rainfall, moisture, temp) {
    let need = 0;
    if (rainfall < 10) need += 40;
    if (moisture < 20) need += 40;
    if (temp > 30) need += 20;
    return Math.min(100, need);
}

function calculateFoodSecurityIndex(transactions, farmers, productions, harvested) {
    const transactionScore = Math.min(100, (transactions / 1000) * 100);
    const farmerScore = Math.min(100, (farmers / 50) * 100);
    const productionScore = Math.min(100, (productions / 200) * 100);
    const harvestRate = productions > 0 ? (harvested / productions) * 100 : 0;
    return (transactionScore + farmerScore + productionScore + harvestRate) / 4;
}

function initializePredictionChart(chartId, chartData) {
    const canvas = document.getElementById(chartId);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');

    new Chart(ctx, {
        type: chartData.type,
        data: chartData,
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            },
            scales: chartData.datasets && chartData.datasets.some(d => d.yAxisID) ? {
                y: { beginAtZero: true },
                y1: {
                    type: 'linear',
                    position: 'right',
                    grid: { drawOnChartArea: false }
                }
            } : { y: { beginAtZero: true } }
        }
    });
}

</script>
</body>
</html>
